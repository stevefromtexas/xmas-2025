<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Merry Christmas, Lil Sizzle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">

    <style>
        :root {
            --cream: #fbf3e6;
            --paper: #f7ecd8;
            --ink: #1f1b16;

            --evergreen: #123a2a;
            --evergreen-2: #0c2a1e;
            --cranberry: #8f1027;
            --gold: #c7a24b;

            --border: rgba(31, 27, 22, 0.18);
            --shadow: 0 28px 90px rgba(0, 0, 0, 0.25);
        }

        body {
            margin: 0;
            flex-direction: column;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;

            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            color: var(--ink);

            background:
                radial-gradient(1200px 900px at 18% 8%, rgba(199, 162, 75, 0.22), transparent 60%),
                radial-gradient(900px 700px at 88% 12%, rgba(143, 16, 39, 0.16), transparent 55%),
                radial-gradient(900px 700px at 50% 115%, rgba(18, 58, 42, 0.18), transparent 60%),
                linear-gradient(180deg, var(--evergreen-2), var(--evergreen));
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 900;
            letter-spacing: .02em;
            background: rgba(199, 162, 75, 0.18);
            border: 1px solid rgba(199, 162, 75, 0.35);
            color: rgba(31, 27, 22, 0.85);
        }

        h1 {
            margin: 12px 0 6px;
            letter-spacing: -0.02em;
            font-family: "Pacifico", cursive;
            font-weight: 400;
            font-style: normal;
        }

        p {
            margin: 0 0 14px;
            line-height: 1.5;
        }

        form.staticrypt-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        input.staticrypt-password {
            flex: 1;
            padding: 12px 12px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.65);
            border: 1px solid rgba(31, 27, 22, 0.20);
            color: var(--ink);
            outline: none;
        }

        input.staticrypt-password:focus {
            border-color: rgba(143, 16, 39, 0.55);
            box-shadow: 0 0 0 2px rgba(143, 16, 39, 0.10);
        }

        button.staticrypt-decrypt-button {
            padding: 12px 14px;
            border-radius: 14px;
            border: 0;
            cursor: pointer;
            font-weight: 950;
            color: var(--cream);
            background: linear-gradient(90deg, var(--cranberry), #b01b34);
            box-shadow: 0 16px 34px rgba(143, 16, 39, 0.20);
        }

        button.staticrypt-decrypt-button:hover {
            filter: brightness(1.04);
        }

        button.staticrypt-decrypt-button:active {
            filter: brightness(0.98);
        }

        .staticrypt-error {
            margin-top: 10px;
            font-size: 13px;
            color: rgba(143, 16, 39, 0.95);
            min-height: 1em;
        }

        /* Layout fix: your #staticrypt-form currently needs vertical layout */
        #staticrypt-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Keep password row looking like it used to */
        #staticrypt-form .staticrypt-password-row {
            display: flex;
            gap: 10px;
        }

        #staticrypt-password {
            flex: 1;
        }

        /* If you don't want to wrap the password/button, you can ignore the row helpers above.
   But this wrapper makes the checkbox not cram into the same row as the button. */

        /* Remember Me styling */
        .remember-wrap {
            display: none;
        }
    </style>
</head>

<body class="staticrypt-body">

    <h1 class="greeting text-amber-100 text-4xl sm:text-5xl mt-2 text-center">Merry Christmas, Lil Sizzle</h1>
    <p class="text-amber-100/90 text-sm sm:text-base mb-6 max-w-[42ch]">
        
    </p>

    <div class="card shadow-[inset_0_1px_0_rgba(255,255,255,0.35)]">
        <div tabindex="0" class="relative bg-black w-[300px] sm:w-[350px] group aspect-video
           flex items-center justify-center cursor-pointer select-none
           transition-all duration-700
           focus:outline-none focus-visible:ring-4 focus-visible:ring-amber-300/30">

            <!-- White inner panel -->
            <div class="absolute inset-0 bg-white flex flex-col items-center py-5 justify-start
             transition-all duration-300
             group-hover:duration-1000 group-active:duration-1000 group-focus-within:duration-1000
             group-hover:-translate-y-16 group-active:-translate-y-16 group-focus-within:-translate-y-16">

                <form id="staticrypt-form" action="#" method="post" class="w-full px-4 space-y-3 shadow-[inset_0_1px_0_rgba(255,255,255,0.35)]">
                    <div class="flex gap-2">
                        <input class="staticrypt-password flex-1 rounded-xl border border-neutral-300 px-3 py-2
                   focus:outline-none focus:ring-2 focus:ring-rose-300" id="staticrypt-password" type="password"
                            placeholder="Password" />

                        <button class="staticrypt-decrypt-button rounded-xl bg-rose-600 px-4 py-2
                   font-semibold text-white hover:bg-rose-700 active:bg-rose-800">
                            Open
                        </button>
                    </div>

                    <label id="staticrypt-remember-label" for="staticrypt-remember" class="staticrypt-remember hidden flex items-center gap-3
                 rounded-xl border border-neutral-200 bg-neutral-50/80 px-3 py-2
                 cursor-pointer select-none">

                        <span class="relative w-5 h-5">
                            <input id="staticrypt-remember" type="checkbox" name="remember"
                                class="peer absolute inset-0 opacity-0 cursor-pointer" />
                            <span class="absolute inset-0 rounded-md border border-neutral-400 bg-white
                     peer-checked:bg-rose-600 peer-checked:border-rose-700
                     transition-all"></span>
                            <span class="absolute inset-0 flex items-center justify-center
                     text-white text-sm opacity-0 peer-checked:opacity-100">
                                âœ“
                            </span>
                        </span>

                        <span class="text-sm font-medium text-neutral-700">
                            Remember me
                        </span>
                    </label>
                </form>
            </div>

            <!-- Wax seal -->
            <div aria-hidden="true"
                class="seal absolute z-40 w-10 aspect-square rounded-full bg-rose-600
            border-4 border-rose-900 text-[10px] font-semibold text-red-100
            flex items-center justify-center text-center pointer-events-none
            transition-all duration-1000
            group-hover:opacity-0 group-active:opacity-0 group-focus-within:opacity-0
            group-hover:scale-0 group-active:scale-0 group-focus-within:scale-0
            group-hover:rotate-180 group-active:rotate-180 group-focus-within:rotate-180
            [clip-path:polygon(50%_0%,_80%_10%,_100%_35%,_100%_70%,_80%_90%,_50%_100%,_20%_90%,_0%_70%,_0%_35%,_20%_10%)]">
                Merry<br />Christmas
            </div>

            <!-- Envelope flaps -->
            <div class="absolute inset-0 bg-amber-100 transition-all duration-1000
             [clip-path:polygon(50%_50%,_100%_0,_0_0)]
             group-hover:[clip-path:polygon(50%_0%,_100%_0,_0_0)]
             group-active:[clip-path:polygon(50%_0%,_100%_0,_0_0)]
             group-focus-within:[clip-path:polygon(50%_0%,_100%_0,_0_0)]">
            </div>

            <div class="absolute inset-0 bg-amber-200
                [clip-path:polygon(50%_50%,_0_0,_0_100%)]"></div>
            <div class="absolute inset-0 bg-amber-100
                [clip-path:polygon(50%_50%,_100%_0,_100%_100%)]"></div>
            <div class="absolute inset-0 bg-amber-200
                [clip-path:polygon(50%_50%,_100%_100%,_0_100%)]"></div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Bad password!",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee63e122affe386f6999fc8a53a15fe8d410913f4ead4fec0a23383bba4ea4ea5eaeb3c0b9bd98fcb9940d645db585f2bbebe78c496df121f484b1f761884d9e68d135114013ee35c55e1fdeaa7b60b05cac77b88d8bee650cc4ec4f5d160a80914261204d30858b87b369d898a331eb74e1b22a261ea598d0491879e3456a4b123f85dcf45da26bbac69c24539a4d8a3c37a686c835763de69417310f8ecbf72d5064016d3c15a15817f61d065140d2f9fceb139211ee1e8202ab7e91ff35cdf8d6a0a0699a0b523720085ae52a01fe85f1862e0f45a412fc4f06ff1f1304fa3c092271bf4e29c0d6de608d684f2f2b615c20f80abbbf90c1034cb0836a4b2716883418207d48b87cbcc3f27df3dabab4664375cb761419094a00c306444c5455027fc87dfd4f235ab9783e320822d2a03485560bfa43c184606e8fa36fd8de1624309296993e42246d2875709c0222ac6983daa4132678efb5abc0603410041d0c0a6ae62f2bfc3c5cffb8fe018396d5a052e7135332f04966d23dec22a869b37185bb4ec46e01f5c5007275c388e0c8b97711d6220c475da4c2db4d645075f676d6a8a04106abf89a1e5d662f15f156aa89014ecff2a274c559b42d223d23df1ae1316797948c7eb21492d5a4a428f4e2c684ebdf8c72622161c7093e6e212eb8035f652520cee2f1598e770b5b6b000c3a6e59f00913b50320d113c5738769ebab3eb42aefe43bf123d685677b678af67c125b6bff27d6e4249976fabf299f40ffdc14677157afbcdb26582c7b49846443ebd29837d75a29e919952b3cb5e220c0f531fc0ea429b5628da6f2e433abf0e41e5e0a1fa97ca565e58a116315dbfcfb13874d40efdaf77a589e27f18f8aee6f101496dd3d6c741bf70f73e42cb901dc6c9f3a712f5ba841ddf2f9a8bd18713056a32821ee7173ecbc2b4e23d555d4df132c2a13dcfaf3ab85c5b57778eff6fb774f3e4703a536d943347f712aff38fbc6aec3c4afa2e4a5b05da50b71a3e75560b83fcf13e3d1100a50fe29acf482ade836f41857e7bc913275ab075767476d82d28eecdbaeec52215598c7e9a4fb3fd3acb55af7ac7e64122ca814e3da6b2ffc17003b7edf8c0ecb13f33963faea8d2de072f6b9df12d85267a29597445f79ef50b3224bb1964f4438d7e326aebca3003e29a3ba362030a95dfb22151998f23dd5418ce3a918dc43d171b929454b4eff8ea8ea9dcb0b15cb5ff368745946c1370ab0f55b62081086d13ad186759421522a3271c401e484225dc3fe98ae667e03edef6344d0df69faa6f11610599552e37060ce2115b721541964152d75be421a6aafc32375ba1f4de8a48ad09fc3ecddbc8db483ad781e3a42ba2ca2997050004c249a6c5dde9e0056d9cd6c050596055ed4c2c63133231742a7d041f7c45a54eebd4f4bcb7f68084d808ebd0e2a2051c13c59cd2141c1c2a5a81286b847a3d79c05c3fea0462393d489a5a7f936b471e6b2955e8be5a06c37e19a60bba31feaa8d58e03f20885b4314b45a9ad4da399306dbd7238dcfb28ac59cc744574cfe8e9c7cc39f0b4cdc7650667b5d891d80298e38f72c2accdaa0283177526b7b300fd1024db373e33c9b238dccb2fe42cb1ed2b29a4ca8a095b9db040d01bd1f1c8e87c9d857fa5e9bbb9bf9b1d10d667a3d219bc767576f1c80beae492028f904b9849a8292d370484b95838c747d2c4681502f004e7f7c5714241945608aba1ae873b4cd65efebaf6637172b5dca16475544a00ebd800465ac009224b99be815c8438425db5f755b0a7f35b3ee5ba34637e45c22d967f7502a60e5f2291366aa2d2fe4fdb2ed6daaefa26cd67bb91b80116f2c66ae29124029726cc7571181c172249793955dcb0c57738fe288ecf57e4c39483618aac18ba62666fc72128f805ee0f920c539fbbec448de1b3015b343f7b4afd97891a6d94f31188e091a493a8d4d516385f7e0a1dee56cd6c04014848e46e7da6a42141552b142a5797b6f20dcf9d13bac5742fdda7c85a3d9f9c010beba684893b5751f89330db567786551f0a4515a5293136899ed853386ed5a63e743a8c07af65bdb8be4db90b001806f089876b2f6adf408df8441493136e74e65195d8c7912ef047e13f87678ffc11f29a0419b172b00a91bc636b38e0581afc9919cbdcdc052747255eb51acbf175768d8626d1bf18784eb37fd700af17b12ed9178a1e9f5f086da9c3604856e5d9ef3291d807a54b697a7ffc0fe73a76d74e9d55747a3424eda125cf7696ab3d5a8073240c0b6d4741282c68e4f47c0dc1d6f712c46836a87b9add6b6b6c4769fc898495631d0e90ec21882245fe40fadbbfaca1e4a8a1350bb2f8eda958779acf18663ace2bdfd22dca3d7aa0b6908af9da2020c476eba2edd11449fa34fba36b744d8cb57b9041eb2f683e7bba73948dfc742f3391487b364a2638e228467937829109e212f07cfbfd1505d6e7e6664aaac132e3395843cdcafa6df0d614de657eaf90878448ea938f4f9b027397860528e12bb363c0a3fe4b026c53ad0235a8a2707ce66be80b2f0e5e8ec37db22330d748328d0f499afd053df2f44df438786c63061b9619b6c1f537b6df5fc44ba5864d51563643edf2b94bbbe55a0241c3003c09c5ed87c0beee51418eeb7f78f0f8cd939301c5ffe5513c44a1eec7aed21ffe7efa67e12734b35a35c5dfe89103af4ced06bb90ac8fbeb20448d6f7a6f20bb5e2cda5864880bf47b6bfa0c5dd86c1f15f3b9867a491b9a8f81ff740e35b5f9e8685eca64fba2e6c900b9f50f1511e3d7d77c143bcd5756dd35ed4e427af9afc944ab878fc7021a9164dcebe59500c3f2294bd25908eddd4407f23276d31dc630fa07726252e47f0038e340e3dab54daf350d58e2ac49bd900f36d8d5c68bb6ac0b4ad497dd2c772bb9f2cc38369cac93fc6d94935aeb17598dfd673542ed818b764c0fe272c7ddbc4a2fd7084255105c540dab606990bb2f4f37905dd881464b33d3225ead9d12a0b9e09b8e21af6bcda2e9ee2e1e129adef2c638fa62d3dbc413e3a7b27d8c89a8d6f046d82c6def0e81705fe27424be7b9ddfc678add25535e3aaa78d4707835afe1d8ea57a552000c1f59cb6c28b8fae9565bf89ff5537028927cfd835e99ff198529b0053849cce7029908b8275a6bc1660ebf0662502adc473272324757a315c95f320bc24cdf72b890e3ae7acae4cd4807283a5f26897b4e6ddb29753f0ef26a93ed065fc7f8567526c527bd95809e26efb96b73ec6b056a3043b75e44e49490381d303ef721f5e45117e504a0030df8a88923f819809a862a29f9ad5f842c591351860f9e93e69acfe5e49060ea4234f2b89fdbf6ba7be9e1c6cef0cd98f32e1da35328f20f37ef35d85789efd7c368d2c93ec297b7bf7fc5f5d5b3b25f9f9a881dd869c64a46de0d3c64fe4bcabc4c0f4b7e8a9d26ad06f6f977db7d68892a4348a52ae51b572d2cdb7ab99e76ea688f7964a92e2fea4cc61e849d4562ae684f5a6c9c06d5e4ed136cbd7a917d4da822c0566178a0f76c36289d92343db99e15c2feeb70c68e8d94e44b1997d745e77aceb96997337764f8de52bc238c1a5ded11c4780970134b4766c5c869aead36937d12777f059b1c4a0cc6c3c22d80fefff9a31a57b303287c322b301544ecf0ca8f25a31b9aebdb08f211281cc7f29375ef6db7e66b025f8f35c16aa90244e5d7a9c483afd51b21ba2ab0523eb212cd2fc1a9fe802cc02308969915ca3daa7d73502e0c5a8ed09e6aa495e396ef8d6ccaa79ca0a758c46e0d7ff0b0f151b8aaa968bda583820dcd47bcedc68240029ab80705a27e8ee4ce9101ffe83a6e21d1594edcc0ccfa1f79ba6122bcdcd277934882c3d64ab2c2a35ef66a75873040f30149d20b15ab6ec5e963a2ac525ec1509ab94ff80e52b66f5db06540eaae05d3f5752256598849e03e7b88421b161935a56cc71917cd3cb5768edbf6e8ea0a35fea5dd7280a4ff300ce16ba2689304a80e0f63330dffc9646e93b63dc8da6b81d98740e30d768bfbba51f081839636f625ec6e442f2f360f355cf98a3bbaa692a26c180b7ad83a902dc8726ad53b49f68f503ad43830396a8bf74772345409c353221a339a7e303c68e49116c68129ceb0c1bca3164e84b5506aeb5703564b81e0e95a8de562d0434e83adfc5d76b07b1691723d119b431e4cd177a538ac9859a10cca1769fe17474a1bc63dcd69ff26dc88d8224c1ab9da62237a7fd2b81a60d5926915414b101aff74c8cc8a50c90bbe5fb024dd3084b2cfb882f41a7189cd7a580771923c0bab59ddfc64b869654d735debecde7d318960ff2f68c006c38b3b027038d3fc74d316f23bd9fb7f8fd4109867556b74c66c1f59fb1d0608fd39d0c000e9c690dd222c3b4f44692fc390ef19710bd6797813644f5c7007daab0dcf77c44b24e78b583e798ea2794d7216ec45349fee085712a50578b9dff4cf784144672cd4262b1efaea2eace8c189263195c17bf752a8ae8c01430a7a3ee8f2cf90e3f9e93539de69a7a4604762947570c388dd658b101e555162e97f860b32068fd2e76a671b3aeed31e5d883d26dd85941276ef8229ea8b5c327af8ee682cc7d482e9152747f39b0143f5fc75674962565ddeea2a94ec869307a1a63c387c4386c43b5e544667fadc953cdce7b9ea40df431401a4de1fc1890e145080563bbab3cf01fb4e15bb51ad5157e39e94e410161a4d503391b3a8dd0c28c22b89835a58f6a62c0c8a6558f321e130d495f4e6778667d7cd12b2495d2a85c2d3ea91e4f7f2afc75349728b5915626cbd261acdaefa5fde21e5eeed8f09357b742d7526fedac73ab770114aff429868fd93f5c46394cdc6035f7e272d0585960acb26bd4ada873e12c48bc56d28a85be2b01f5d3d119956e95e7895110bf9fe0948e949180201727317116f8394d40deb5ebebb66cd89ebcc6dd053dc0e071e92ab089630e1a04cfc4bcd639fcc5bb6386d48c8cb49486b67bf07b53a36bf79b95b4bd1ca8543a0f822ad2c62098a37fefdc9dc399fb1dc95bb2f93426b9b39ef76df722fa23f9793e3085e5de6678c634c6305d472b526dd050787425622145b093e2a60de673ef64c3cc427fd481e39c6e4f4970433e3caae3f973ce4808369b6f9a62a6bfc8fcd75d4bd37882ab68b3d00e9e9cab87dff26bb3a99044cfed4103c5ac83b08dabd74c9e2e09bc40a3c1163177dfcea459c43f703378cd5448f4c1ffd0792231f186562fb8ef299f910441711c8911ee191487fd91f9d99ad2b96cab7bd66a78a62edeae9a469b1d540b19d38f3cbce057dc9f190821cfa7e501af9fb226b1e1afc3819ddd1fba0a305e8f5323248f76a2926ec977ebb562e78f7ef8e5c44308a042749261f4b40e5e2c83f9cfc510e7875f46a3d0e197d35669497f41fe0278ad62d3335cbe32761f793168823d803c6783993e5b443a61b6ebbd7c429c3a8d44d5892556976c5668c48b693ea28617c1d22929cf4e28741d09dfabd2033f25f9e62080f0dabca81fb8010312ababd5811bd58b4684e05c456e494587083e16315780e81de74516d3be813829acba3312568ff96d6ee4dbb4e098bb502f70accc1be59f68ece4c2cf68889499bf5b10012836ea83f32141dfb6cc79b2922040143ae308b617c05daa298d5e1295784ae14684e00b22cf04a43f3025381a8c8ab95928222a57e1fab75bba9dc9c741d539ff72acf9ecc15b8381ad07e3193767cbe701d63854146c8147f011a79c870b2af55d192d25a8f2af512cdf6bedd11e9357f6873152e0301c6eaa11717e69541f4075619711083e1b1c0e05bea110a38b5b608f79639071397ec610c98c80ee4bf5068251648aa8d1e2c43a93231aa1050ac74049784647debbdd49e9bbd02918d0d8cad2a2031e35a50a2de417dfa92d9138985d1f4a8bd5ef9d9984d8f6526bb48ce94e3ae28ac73faa2a2c61239b9d86fd19f49621601fc11394d4d849898ba2b73d94aaf953003ce3c6f6f6a8de7b03a0c0740ebb7789336598f433debebde25dd5ba8395e705b9303bf7864a937203236be4d66a844630cbf7395c36174f68936260a151cf6c4dc2a5513e79c7cc72ee9be2f7ffad526603451edd620f78842d08feb910fa2b9688a86f9dac08ea29f1eda4df657f9a0b01beb6c6e15bc1bf08eaa3685c068b4d96e988561b0d543dfb5985b2297d924702e4c189bffc6f25a83b42bb8205a17720b6794b5f76af51fcbc0704e29d7bba9b32d58b5e68388b18985e788a8c745611de9940904d67e8071ea8c53bcea8119506ad01ac0da9d990db9a4e8fad3c131c1c14e03e07a3049e5363176881c91a7c7d3143632331cec2fcb68685fdfa52abbb2795a28639db781b2ae791148cbcb50f77400e777f5793c040c1f2d338ddcacaa3f96801830a6e7b92023e21ebf57c82bee88819b8bed3b91bdda684f35ef740ebdf3e07b09391d0fac08e7cd173f9b471c6a8c72086f6be3b147c6de98429cc6271c2b638276f19d869b9df54a1f1fc2bc38461bd92f002fa19c675036e601ee6bc86d9cc3386726f72c49a89dd9c885d9bbf83161b825108ba1d15842b42b85750016eafc226bec9cb1d5bec017ca67ac32d25855355369eeed393ed979e5d291373d8ca36ebcb906b6ecb2711f2eb19a105ab204cec2b11737f182383f0f74a5411e87486777cb6ef3601932f448ac9db12da850bc8c1608786b57195b97d69346c5a769f08aca11162b0a40919fe74e8e14bead06bd6c0d954d252dee58757bc0134910ad11fe7a3de6acd9551f43a591cc02050be901a6ddce8d763ba659818659733bc0b3e69c0e08f69c3a10ee6b4c1abbd03f557fb415f0a3acb7eb771c49c58ed93a0ecc83f72b03a87864a65da1f97ddb98fdabc955a7e403ee2f13c07ed53cfa19505dfe7e9be685639c1fa2f6bc16053392ddf75de56e2af081fa4ecfa947df96e6d71af07777e3d04f8cbe02ee1c65a40e6a4d3bf90b4377b48baf8dedf1a0321d9765e891f49d0d2ae127f7d93df4c21348cfd2f31c8ba751436dd60a754cc92fb540b61aa74a532fb99b6cf0d0836d03d6dac34fafe41aafc3fff1860aa7ab9bd99e5084a427871a8ac32bc5a0774cdccfee1c16bb8e0deffa385a363e0cbd51389c3995e1330cc6db06929d65d1371ba38474676e60a169b0556004a4eaef7dca61289ad2c6dbf92aca7d3ed3dfe01d644ca4afebd0b73c4bda9c643995c7b4c1ea30a56aeaa8d8c72906b5c789595f84bace007a47f0e2d2bd40f3f15837509deea0649aa90cbeb381f4041fda33cf8152f0d945fb1791e77dc1be7b525426a0f91824f56e99e796f6f3d9d349bba5270eabca6ef1e6ce2064d159b7d71a9dcc701145ffc127aa493e4faf90b2474900aa822425a4a70261e6a05f5cd2ac48c590855c1ddaa951502826646717b7039e540784f5658aa9572e332684b883a0990e89bfef42d38dce635ad1cf0d2820ec1004fa064f7107eb53abc735b2d25d468bd1478bcbd1e8b38c0faa03222f9cbc8b46040b9f7b30190220f0db8794529fa8329728214479524c060ddddc775f30cb611c8e411b038841b10882f426f21ca0378c762f9970060c93e014b0b84bdf1726e9851af6bb5daf8940f2a6d75e5f334ab316214a784a91f78fe8c8d4d2da4fe72a48e76904dc19e8071de8efb2b172e8d68a1995a9fc0090702361fbe00f60430b481d05e7fc22563523f2d84a5138007ed8a632108032ef9297a7a410da77b4f75b49f23faaf29fcd46629ddfc53c72b83561bd03c51b11865f2732c666274bd986ad01384f26f4e6488f14ceb523a0fc1f5b0ce51588dae22c6dd8568c0459f5242f928990a2d5ffae073483bae04d525ca54a75e813b4682d04d6d5f7c2423bedcfe17e56c85d1b9e4022f9c2b83ed7f1b57b3bfd9991b0aeee9bdaff01672b14c8a685a31b4f37026fc241466571007cc959e975ed019824ed92d0dc849753a7eb1adf4739db017808cdcfda5804f9d0ce40abe3f43245d341601b0b08bff2e8cc04d276dacd21300bc8b5cf5870ac651e1abd98249ef0a554072251042f4d434ac0d7c77f6f3822e7cbf65eb137aa2d6783677c03fc9b379a811123ce1e7379600317ec997c7f6a7645a7d4926e88f3e62f48786ecbf0b1bfe3004706b18bbbcb7705d1dc484877183bdbdd793dcf55a153494c452811027c914c6ae3434dcb8fca1a5592724003904a958e9ae5b7349f5d3b5d9f47821a457e445ea42a5adb42ac8637ae67b46eaedf20624a087fc38ea9bd42246da0faf3eb9e030581bc5d3ae7f13be719fd7d224713336b2a5ceb02d11bc5d11d3a9e56e9753a2b3ae36cb6328b20490f94f235a9f5ce3c28bbe9f273945d62d921e5153c2b9c481fb3446693d1fd70024e69e287d2005cea6b008bce6d16e6c0e857c554211775990a789427154915b670f61871bb12521e14e166aa0091b17a2d9818eafc9b63d7724e1fa8fa304ab2e15590b3709119964f319bbc22ac6f56446c51139da0e6d15a06b44b2c3d8a72b6b1ab9d1474f7d34c794fd38726509528cb2b9f96dd8738ccb7f747e4ec8712a7a0e6a177b4724aa7fee4a1ace6fbcf1081915c333d46b99a90330bdb3617364f37a2433a7eda8df07ffd51cd943d78daadfa46dd1a372de8e75e95de5c3f24ba15c6e487f6248416c0bf29cbc3439a86e24b44e1d21d9d805bb656f836e69fc0c439b67487b2851b4671b82bfad4acd88b9021c1c4d2be203c64491b4b10a432989fc02b6e7a13453bf13c88039bab161e09997d4c8ce9c807772b04daa727df56ea6e5227b0a0c4c0376caec70f38a8237494e9bb255675dd1556f8401fd0a992a607026b7d589f9378984ce732111ab8baa28aab7d466a79697ee0ad6c6b958b61cb64926f4d2bf9051cb712e8620a657bc4f445bda881a744c733167823b8ecc60489c6d946cf654f282cb82958fdc741091ea425daed7a2083a5061160a94d97856c91091dd4f0b5b6cf12d97f50c289471e144b248782b277a258197d667a710d86c84c0cc57959c49ac1cb04bfeb1b70aaf4335156205dcf0cbf606f95172508601f02767d3cce867a57ed4d1e0a96aefba8710e75b4169fb64c028d3708dcfbe4e932b97f41d88d6a4d64743084a68e5468bc61665f303e77e2804f0ecf8ad16aed79d9dab18b2ea90f6ee35be87498ae9abfd7154bb3a518b61b508ec7fc0ec642e0dcf6f8c630c088c6ab8596d00a9b3d1a69b2e76f254abf2135505d2f271c4136b3ed81a28264d8aff94b64bdc9449d40e7e4045f5e7947004286c33e57189b2f172f722fb9555e65ed96d13190b217f7edf75c96845180423ad20ae7a7624879407e814e9b7eb260301243ff6a55e0b03a3c8c0e728ab4b6442a04f5f4a28b0731d66a5b2c2f1dd188f4438707cdacb6f51f154f9406d34731aaccb979b594772e5147f97b37fe7ce67d4207c0626fab9a7351e5f0eabc50808fe0704b73923f51e51d7fe338828f889a16d6562a5f1b51a17b64091fa9f42a45f0d36c3391799b63bc72d7cccbcd144204544e0d794222be70e84e3fc7bde339ea785a5cc86c02d11a9b73a7b5b5c656f03ff95414f2fe724f7bb35ae90e460b2fdc0d99babb68d536c2665423e968a86c6948eb8ab356e3ee6d5313c5a22c51411e34bec2c48e26641659a06b06ac996bddc958fff17462817a750e73cd7649f754786bd19075cb05426990d7ae8b8e9efad8306f00f3b226aa281630821edf93613cd025997fa79fcfc83efbb95ef7ca6e71ce6d086f562273b9db6eb7527ee819d1ec34ea15958741b15df153ae0ef17c30397b14ab46af3ac7e12839b4435d63ebb86b326de8a153ad27d2bfeba1c0de6df1bf13a24e56b22e5918b76db1716066707e8b371243f03d22d50c4f613676b8d0529f5daf062e4886c6e8df0e9168de581b3c07168476c91d197d44130e5680c96f9ab651493ae572354a182bf8277a8d8c45294657a7d455e0807943ca2092d717e4f512da06cb71a0bdedcd910b67b198153ebd3b1991ae81050fc64b4a7068a413ac659a1971248ad5491a1c5ac9cb175f5cb9524a1b2caa64b5a1e66e3b88367112898620fd012659f6c500668fff383f8597fa4d9b90a6a7a354836e795bb6be410df844b81c0432d15b714f38fe8d2ebfb6f5bb68ba0d935fe4a436181681ae50b56290f31c6f81707388e9a7cf5921cec30e66fe1a773829b0c409e05f1b85af6ca7ef7be9096faa933966f8a7916283a0396ff366aaa6c69beda3f61a0d140be54a6aabafc37175fbd8320ce4a3d7390083d3007d9281c6cc97705dd9a896064aa18f7cd69c10954fc6a3c55759edd81a53117821bbd409dcb43dda01fbdcb7e6a6e36b4a89d4b34252e285d2b4099fc8c0100527dc1a1c6015412d73eaea059f1ea26b962908af484cfb9fceb26667c81ac246ad6a2b5c4c9585ffaad4641dc691c8e4d819ade9ed9fa9e77d910168f2f927d90a43804a4dce26347c746edc6dfa40ba311c71efb475a0ed393d7038838944b3fc32ca3ca95249bf2d8f2ee29611a753cf5cfc058e27cbc29747aa8aba0f8b134272133f464d77d50b8147a83c65199d944ac5f165162695bd6723291dc429eeda84a40bdf32a8075af72511da4b3360be5e307e80cd17d633041e8dd882ce6f8592ae628ccc3150ef7144c70fa4dc237590139acb68a2b385e4a9e3126dc660e7dffeea1f530e391ec4e4bcf184151d8ec1bbf1315b76fb7659ca404b6116a782c16328659b721c7c0ae48a7befdd323b3c6600dc1c77450e9ffcb7fd4baa6462d3cc76b1cc718dbef20b4ff995ba5be0f6e1f4a3fdf151af848df26f1d1306555945305bd907ef572e359993a1bf20dd1bdf06ad376354e3a1b52bcfe963cc88a7fa552ab3f2dd0fbd3c59972eaa87d82009085aab44286e8ca15b984737aebc6e81adcf1c1c897d35d0211040ed95328d2810feb4487ac384d0e51247cf8582f0b1e737b786a541f364ba8394bf7f49f0b7d91b5e8ea3623957f40b62d52da5cf4b6e43a172106dd5530ab173675f8db29ebd883ea2e090e46094d1fa85cd61c5b1391ece704d69383042fdd40de8cf3a3974986f62d977f0f012810fe18ee9baed8e2eb7cae39aa7f9af5c187ac9103e42bc247294c883f139a0454f0625dc5551a50ca2f7283baf8f732f033ab060993a57b0197c6e1aa68612713c6674bb698ea8cd676439865a89bc1bf2d0186fe97ba14b88d32543ffd456e293c6408c06846c1418eccfca11ccba49caa4532fc01e6e800aad4609f8b0f05b951501006b4be2edfe5153f7aa66f45224425797821318478c00b6786b4636e47f8f878afb9007148e3c1d7cbe1072f27b9e94fde2fae18dc332ae2f623855dc34813d3467c54e1181e42c009fec3c41006794493c4fb8d1711e02cd3a204982535e06a67459c68b1988e402adda4f135df2cef3969959670a6e553c9e2848a323a214ba804ea62b91deb4e49c0cf1c449f518883a70e7164382e5f67ac0e982d8137e3d8d90b2356763085b45e27f3df832db5398edd3a293fd69ad2a7622fcef748eff53005b5773a5696f812803ec90fa666a9108419d09ed2fab4a89d4399a9ea055b0173a547dfe4106fd1970d7d3bdc1607a1e92a7457be11975821fbed9a7e4df2e8f406281dbc6be898c7a2564cdb53f049e732d0b877f6a05de2af3dc93f5752fe7991e46e53aa980f6ef9cf8883e896cec5d38882b5225ca18f5d91a2dca5a28d8d548b2ba4fd64f5a1a01e633ca10625efa40ed0d437c94ddb19e775c249907fd0da188ed60bc1b2e2e3b2beb462df7d386d601f252416da688e89be1f17d8d994e2da7613810953e5a9139a19d4cc64547a7b04ccc3e32573ec246626c66d0026041f1b464c93f83e2b39f8ee67ab230d7807b154c4e3152470544781cb61cabdb6d912bb34a4d7f7208c6ce86e7e44f96d4c248ef1f9abae1f3abd02d7213f07c82bce452de07e44eb5e217392c2e06454afb47e0e169358c1061a76d671ac203d4540f31ce2e0a0c77b6a4065eca22ce99395f9d9c616922a405654a1183968e865cb8053d8eaf5202445859cd79b1cc307e229566cc61b72b9f3daba6d88ff69d1805ccf7cacf0aee03d9ca5712348d191f4f6caff1e2d8d7bd38fa9ef62bf391773bcff00776786b1587b4265e0f02f1ddccae7e54bb07d018894dc2205afb2b4af1322fcf95d7de0e583a015c18e649cc819f5dc177e3bee2c4e4343ff30dbd7c9ec71d9e48a42a410c58017b02eae7dd47775ed9dd6c3cbb654b3ae213d55dba6346fdf8e1e80c5b1fbf0442ed8b8cdc5dfa9b3eda1b5847185d3ecb8b907de7d6fe1fcf6910c59b8b9cee18d7378185e93e99255646248034c6419b4fa7b58f175e8a99281adecee8a20681df9b61f1a2aa693c1bc1e2d579b2785ed26c19439f7540fa3d8ddec2f0402f18cf8573a491171920c65aff5b99befd240f6175bde2d084a0b9749ee1a199b0702ff635aa4e0113c25a171929d7820cc29ada308249c8a469ba6b7ab7fee20d7753c21e0b545bdfe290f0fdd63787bf135bd981d70666216efdccdf95314be77014896382378bc9d57f0580b7df7479073bebbe759a1decce16998c73bf371d7b69ba233da7ee34e89b52170f0b2586481d164ef275a7961530b09d38f536f98c3c8ee061d559be8275c81c53ac33de7edffdf8ce58bc6aceb554d3a2a927495f964fb6cb42f662d6ee22034eccdf31e0a44efa71f73702d21b1c67bd6ba479c87167c6b959efc6f6f757d5f1d0d200bac06e132327c07a78a4d95b32ae0e1488407e0b1f6c65474b48ebff4eff8a9773fa8d62b814cf13c5dd72b67a48e99f5a26783dfa37f1e12d3ab0a9a72e0f025e967087c4fd583a56be56c2debb38cab693b55abbb494fffcd5670317140224f1b9e686fb2db001a03d7382946c3d65e19310349db44486caae7146554613c8554d9777ff87f65e7d365d04af7a75503f149b381d8e20e578e0c44ba96cd2f6a3a3d18bbbdbb0a216743a21bc5152899dddb2334973c35885f60034caa0c32f37235e622c334c98c16493b3867c1ecc0323b69e4d155b93093876c32fb60de872aa7c8751d82945662727feca1eec05f613bd7cdc814f8cdf7eebbc085a0ceccc3b208fa47dfb8bcbe4c21a13184d1e90b62520c979f0d1e40b34b8b34e969d5dd305bd25059070c16b07c4b97ad97a8d04e2c5bf4bb03f8e60b4bc527ba2bab1e8af32d3d17a5e6ec72a5d81b8429b26efa5bc158e1770d32c8dc5695e144b074ce4df7d9c54c0d2925af83ba74e05df79172f9111a02b1fa889646ae2bf99da934d1ad8fc7c660afde24001ec575dc207c83a917047457c0cc576287eef111822e8255f1a212d32a591bcf24f78ec21f6fe11aa1279460e7e35bca532c166601ec8f9130dc55a89878c9a503dd3987857a6f5f396190565ca06785fc06ae0afecf5e9d81fb3e5ddb5d7ec23e99fafdd117eb2ead2e68fa801c5769ec18d47dbf485e3867bd3a7e946159a4dcd7f73448d5c8f78c366fa41dc6100bcd3381513b49d0ddefb3a6d134f4d2e29c69a695ef72c335700c6d81bff7eae16ec11dce07efa8e4b9ea245956219146627239f822a594d9ecbb0779009875df40296fdb0f84c08e8f0887827825eda785913bceca5d9b0b8fc282dba728b55594b7e634e40c3132117fda976d141de81318acf1519d9b2414a9f23741bb60eedd564ee853c20ddafbd9816b588224363d39d85c8060253f5c1e9f87e7bf50da3529839715750c2af604909e848a1c38f455f0fed416f895a79388a5e4b5c9cbea91d86979fd313620e378023a6ad1cf5e374334cb49d4c549ff03be7ca2f151cfbdcabeacfad048db4dedb4a876d6a0a793cb32b77d39ae2743b0e631b70f550377df1b7e69feb5d9a79624a39d8c259585b567a607daf4441157308b6e6c4334efd9960d35b56700c545379afbfbf99697611020a602784405a14329896d87584e7491528f6ee3ebd85c3b1a8c6b6459a2ed7a0879767737e60118796a4af3ad95d841d987708f2d2caa96b749ebf9534184fc0baaa1156349fe1b421b90ad909be2c786814e089d2288edd15e487b61b2af9f5a0e163950c90438b65ef3e86cf172a4c9451c4960bebab08cc618784d89c7dfbdd3de4dcb95d3fcc495436bd80e5357e2b249a4ac9460aebcbaec0e963c6c6d886c783a20be1dc4767e04b4d43419cd409fd146c3d5e33659d0a7fdacafb0a628a4aeeab3b73937258820991902328351b9d1abeb46658b9a7da95e8fef225909d6400f54f91d2e2255b5d8e714fef674665e3be8e4cc8637b2b5895f3a1ff96c0d35e00507bbcbea7d92e94e8edd0b46dc2c59f2c3e154a0a3866d11ae5cc101c47f4a405e95624330f618856c6ad04d9cc12ee681fa66369fa4bb9ae6702dffee0e78a5e0f9719cdb5f39d145208b565f47fb26ebfc55f9bc934adaf3290ac9f3fbfbbaa95f590c2b9bf732518a2455736ce22464563c31e0453a21d9534d4880d86e5f570f295dd68d3c9b9947c2bf1d69a0fec9811706159e6904b003279c67f4fe8b340b5e13d91d50ad5221ce13adf0b12916e093a4c168768fabebd8411f64b14b3e25a94a40109b4b61b271f2f33a0cc4511baf4e07f90c925f5f586bb73d8c4705dccb012ab7d57b641b99e02cdd3e9ef0c6b19ba59f91e664f803a8414415f727fbba182bcbd9a95577ad7fe8510ee36170210675fb89d1ea59ba30757549ebe360b99a8da14c1cebc4bcc4a9a33085e4af7bdc92315fd1a1846bcea6e5d9fe863b8df04b7a6d08aed1a8754426f479f2af4a6e2010c261bcd9c1f11347b85337fa4bc3251febeab42c95ffc8c09d85e5569e25decddfa668267620eaf5b32164238d1fbd51fb9de6883c72b1fa75b3d67be16a6fc3d68502e98b655379b360f4478eda18dfc2c83ab14edde6a37e94d87f85387491578c2dd575e35171011b689e85254b16a2cad3cc8c50c8dc6d7f1816c4478867f93dccfd9cd80e3c9d16d156be4e1e0ac589da5b74bc075fb71cb2215f040495fcca1791d544a6d03b3952c44a839062e0095a19029112d1585739b70e039e301f379095bea4c94707fd11899a9b5cea0a081505b6f00cbd3af36ba24454418b18a4a48c7bf1730f31247cb42dad026429ebabb3ea76d3da7961cf3d3db056ffcbc02011e5f0a52aee58735ce5308e4c6a5196fb0c0719070075e79fc71a907f131630318633cd904cd14eff291d80ea5c4d94311ec0867ecdf5d3b5296f611779e87476e5c91a12721930ddf157df6e5b4925fff04a23f89f2f13871964322446dd62604bb80a93cdc02725c645f1c6f370ea63cfd8e660e6519f9ad0ed91a3267de06afd7c246769d0a20cbe10818f3b92cef8a68b3a425746522a6c6137391f2c97441a42fdce4857c2ad0b4674e127b86240296dc861011f7327334aedbf64b7620bbdada42888ba0486b5830ed8c9431144b8487fbbce7dfbe1a7cb9c7cbe434471e091cc64c4e452fc2c65afcece9532819bba9e266c3303368a8c0cc7ad64058a3771978153d2c161a21d500a694b579940041e75b4f4d063f4fab0a21cd05b6003c956301dfaeab95f594accf3941a5ea7e32b15fb282a845e800a8aa4a28424c3e04362f2b0c3350c0dd6dd9446c641adbd1fa33ae79b5d5dee7b243ae74f8009a5e617ceab17f33dbc393b1ea3b7f97520ef0bdf6ea21efb971d1dea2b5cdd2f2826bce00762ed154de33eb74351bbf14b66b1fbdd948109efeb9a9bde875557741e1294e9c500c3d1dda583560387ed25d7a450f124c0da3de76c1ae2c9418a2b50d179379aeb80814376b7ec6d05e0d8548f5cb3162b2ca0c52a6f767b9a02629ac5bd36a2edea03004ce35c5df914311160ba5c1b7b46f70f7c917a3020aaa1a420e014b6573c973ac60029f6d3a5d8947eac931fcdb0f6fd8c3f2c3028bd0be590ce5fd857069f00f83db1f23bef5a2664370ad94ff8ac9c7dc0e665d654c0b465cd18942b8b3c9efe48b4bd1e37088db1d187267f09b044c20e03ff6884f99b8b95625215ddcd1558181174dce88e51a2ef1c325597275fa2c52d78edbb409e87d451bc27249e9db67704f3d9816bcd4f5fa258d9c2df0b94b463e231d04ffa97eee1087aab742b6178a794977be35d20a8ef3bd8f684f6645534be404cf229e719db757fe9a2c69230fc36fc9ba9d4ac30a5da0da5fade86222c321515ead502e17a122bac184758139f66bf3743ad706a93cfae6ec7b13383b210ea84ef5a652ffa8753c66b6c8949623786651080f4d895570f663caec22cffd2112a2ba2b7f9e2959ad18ee0fc74c00812c5e761150a65c842595255777e90e3f067bd353186889d61f0367989bab142dd1803baa77d49fc464c239bfe3b4ae1071c3f3d3a4aa969953698cb5212c04479973ad960566f6e9bbd2376dadfa922057f40ee8ed41a70aeae20806839ac7234803dc064e3e190f9a5418ed39c0ebdff262350edfecd28c2c688eb43bf2202b8a46dd2340d3511aedb54d59318e1d34967100f86822bb777940161c4956ce9d7b271dd3eb8bb595d7eac4f2927145f5d9f78e3cc4b6a8ec9cf944a12f6b3856eaddf8c90a7e4a49194eff8b2f1549671fa99ef38b45ca5fc0ab4c944e60098dc24c2d46621237b7f799b6a30309965041a392123bc2106ab098c54da762fcefc865758eff1405c9a29feb024d31819f5c3f6df8e7bab25f73178e59b2f84f0d1ed36157edbbcb4439af95b0001d8872562c62be378d9c02395e97e745ce823e54316b3f465a0a5378cb5f918d05bc54b1921600a39487c1faeeab5d58118b1a555ca9b2efeb05b0d23c3833a3515cf5c999459846cafeb9bf60fc337c558a3056ad7170a8aab3281ef5ae302035c35056a093d11f793890f3257ef73f79ea99d318aeea4f8833616f5db753fa99ea8e43c19f044556b6fe5d9b6336ba05322c7a6ca636078e5b1150fec2faf68d4ed7a637cc7912670a7801595ff289cae2d654a2fa1725ad5edb566c7e0b8f6400883acd75e425d036d1ff4c207d5f18b9904c98ec611e326614e945cf57fcf13ae3d8b3ff04a4d67247bfb1887216b66900c71284004df044225400c03a093c331b8abb33a49e3d06ff153493d6529c5e62ad0a275f3554627098fc9c49dfdac5c9a30acc4555640b41cfc3e8885b5fea5c61a55c10d185eb8ef0a45cc5e8e76ce6ff9970863a2f8adfc3ccdeb222c51e4b5cc3f55290cbb58d671e9e988ad008d239f471461b00a79631293ba6a586f1795dbead9c64826e725d52deb55612670113964872c3700650974e553875a2cf18456a023db2e41a302fc83908f549c218ed5ccd1b66d36022d6a11b72041a058993224bef4ff16b41a096cea1b7d2f685f590a08017b8c1d0cb3115281a04bfc6bdeb7184936748ee7f75e7c53ce4e8b16aecc1c538d7af281686f05e986f185c9b174356fb0011d0e3438316f88e749df3f41f7ddd2b29d6df458e6cd553ec26ea222479c1d585c0782d554a11acb80a11a63df6bcbfec216601f347fdf4388dbd3fd08d7a30ed268953844d21ffff6020bc5dd7e2b221c876a79338c72152963b2cb8f9715b5b0b959a77eca477548a6b0e05ab62ca13c88dd011fb3564f87056c8812b247ad3569470456f30a27ada6a61fd20ac83c63118923d27061b23459f632225560209155ca6ba05f8e9982a86df2742a16467a65d19ad18d457e6a99101a8b1b29e57e85dab0f0e8688b2617c9eba01b075cd06ea9b7678d5d5efe534d7b783c5538995fc8ff2da4e91c0589da171fd5f2e6ed964d5b31adb1b89e51f95ffffd25a5397f526006aa0e5b40bcb29a7ea0ca13a5e67eebf6c52bfba2442f83a8cb6ac4953dec6931790f2fa9cac79e107e7a2849dbc7ec8528f09216525efa72b37d9cbf781c60c15b7b1cfc1ec628cab1a02fdade1769939800e6f1ce0fb66d8236db1368e7b19a551fb9ec704dff863ce0765d7ef1d5489605af3384def1c881e74a9ac22f1e16f748aee1307b7d13c2c320cc80bc5185ced187ac4148539ba69cbe89b3dbc32d7d18774767aadc4a6e8d1f7e966359826a139378fd3a2d156582049a0e3b496fbf6557e2b5d9882b5bb4478cb87df6fdbf45032cebfd0461ad7964c483ebdf5cfcfcf666f5c4b3aa62dc456f53103fdd722535da30ad5c6dd55263032bd41831a6aa8032e8aa2c565a0ef0f1775c1c25cefe9ab92460a28c8c581b87e61bff332dea704d9e9e2af07f6f69abb099cd808ff74cc71cb7ac4a1438de431091a0a4db56ea0f87ce20f82dbe5861a15d224e1ae8a77f63dd082dcb26f60f43a81a93c4facb94c54d7a38480bf2db65cccfa97d8f6cf6a37c91c0f541569bd549476615ef91c619ef0fa41f1b3b95c24e93d96d075df836186dd32f8f2be45c34e1a74fd0729355743646e13977f5fc15a88c1914ffd66dc26640e811152e3fbb71cb03850cde8901e8b2e5c028a6cc4dda5e9739d2403155216d1b0ca644e79fe5b56a5b5468ce15794f0b71ed29efa84220b3a5efe7b5c2d617d49bee99a6b0d499bdbc4e06cde90876bf6a1a3995c3f75e4b9d8fba9ce9f3fa3e666b6993a163b3674d1e9e0f4a79141803e295317bb6289333a83c1db1f3bdf0f09dd628fda2159ab7d2a75351296e17e906ac809df52030c38ff8a540e93cf3e4d0e2bca0bdeac6acdae4a41318ff9e4d1eca948d9e6daf7d0ca875b5eedb6c7e8813ccf17a7d8bfc3055dcd25334b8f312fd915d404ee155a59576e2730e0b03240a5fbe934f18bd26837f767a35119400809e79a18ac431addbae495826aef588dacb2b4a15107256954ee1355a9c1ed810b9638455fe13b09db9cf76a47c8ed0d503a0497f692dfef12b0e658ee2e5c698be85a85a60ff5c39b651618e45ebae7de1b1ce5e95ed89a45d53bd37fd881f247c7766356aba3a151388371f874bb0fd5b4430d4865545933e89110c7ea4e045201601a844f062ab7faaf1145613fd4042bfc94559bc97dae50e1406218161ca04a9eb57d2a126ffb9e946c56028883626db3eb5783013d5c0219c688e4e62dd1534a0a9add44ade58e7b93f3c5b65e6edc9c483873ce549e2da3fbce4761517d6ac05efa1c6dce8bb2c2b141502e171cbe2c870394ef5eff842c8f4117b5152d26238696f8a2efc0372bdfbfd3890ce87e3410473b854122a1771fe34b53cf3274b9d6b520b8cae5721a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"87c8a93c9e89efacbb43c81c7d6ccc4f"};

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>