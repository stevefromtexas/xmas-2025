<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Merry Christmas, Lil Sizzle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">

    <style>
        :root {
            --cream: #fbf3e6;
            --paper: #f7ecd8;
            --ink: #1f1b16;

            --evergreen: #123a2a;
            --evergreen-2: #0c2a1e;
            --cranberry: #8f1027;
            --gold: #c7a24b;

            --border: rgba(31, 27, 22, 0.18);
            --shadow: 0 28px 90px rgba(0, 0, 0, 0.25);
        }

        body {
            margin: 0;
            flex-direction: column;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;

            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            color: var(--ink);

            background:
                radial-gradient(1200px 900px at 18% 8%, rgba(199, 162, 75, 0.22), transparent 60%),
                radial-gradient(900px 700px at 88% 12%, rgba(143, 16, 39, 0.16), transparent 55%),
                radial-gradient(900px 700px at 50% 115%, rgba(18, 58, 42, 0.18), transparent 60%),
                linear-gradient(180deg, var(--evergreen-2), var(--evergreen));
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 900;
            letter-spacing: .02em;
            background: rgba(199, 162, 75, 0.18);
            border: 1px solid rgba(199, 162, 75, 0.35);
            color: rgba(31, 27, 22, 0.85);
        }

        h1 {
            margin: 12px 0 6px;
            letter-spacing: -0.02em;
            font-family: "Pacifico", cursive;
            font-weight: 400;
            font-style: normal;
        }

        p {
            margin: 0 0 14px;
            line-height: 1.5;
        }

        form.staticrypt-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        input.staticrypt-password {
            flex: 1;
            padding: 12px 12px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.65);
            border: 1px solid rgba(31, 27, 22, 0.20);
            color: var(--ink);
            outline: none;
        }

        input.staticrypt-password:focus {
            border-color: rgba(143, 16, 39, 0.55);
            box-shadow: 0 0 0 2px rgba(143, 16, 39, 0.10);
        }

        button.staticrypt-decrypt-button {
            padding: 12px 14px;
            border-radius: 14px;
            border: 0;
            cursor: pointer;
            font-weight: 950;
            color: var(--cream);
            background: linear-gradient(90deg, var(--cranberry), #b01b34);
            box-shadow: 0 16px 34px rgba(143, 16, 39, 0.20);
        }

        button.staticrypt-decrypt-button:hover {
            filter: brightness(1.04);
        }

        button.staticrypt-decrypt-button:active {
            filter: brightness(0.98);
        }

        .staticrypt-error {
            margin-top: 10px;
            font-size: 13px;
            color: rgba(143, 16, 39, 0.95);
            min-height: 1em;
        }

        /* Layout fix: your #staticrypt-form currently needs vertical layout */
        #staticrypt-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Keep password row looking like it used to */
        #staticrypt-form .staticrypt-password-row {
            display: flex;
            gap: 10px;
        }

        #staticrypt-password {
            flex: 1;
        }

        /* If you don't want to wrap the password/button, you can ignore the row helpers above.
   But this wrapper makes the checkbox not cram into the same row as the button. */

        /* Remember Me styling */
        .remember-wrap {
            display: none;
        }
    </style>
</head>

<body class="staticrypt-body">

    <h1 class="greeting text-amber-100 text-4xl sm:text-5xl mt-2 text-center">Merry Christmas, Lil Sizzle</h1>
    <p class="text-amber-100/90 text-sm sm:text-base mb-6 max-w-[42ch]">
        
    </p>

    <div class="card shadow-[inset_0_1px_0_rgba(255,255,255,0.35)]">
        <div tabindex="0" class="relative bg-black w-[300px] sm:w-[350px] group aspect-video
           flex items-center justify-center cursor-pointer select-none
           transition-all duration-700
           focus:outline-none focus-visible:ring-4 focus-visible:ring-amber-300/30">

            <!-- White inner panel -->
            <div class="absolute inset-0 bg-white flex flex-col items-center py-5 justify-start
             transition-all duration-300
             group-hover:duration-1000 group-active:duration-1000 group-focus-within:duration-1000
             group-hover:-translate-y-16 group-active:-translate-y-16 group-focus-within:-translate-y-16">

                <form id="staticrypt-form" action="#" method="post" class="w-full px-4 space-y-3 shadow-[inset_0_1px_0_rgba(255,255,255,0.35)]">
                    <div class="flex gap-2">
                        <input class="staticrypt-password flex-1 rounded-xl border border-neutral-300 px-3 py-2
                   focus:outline-none focus:ring-2 focus:ring-rose-300" id="staticrypt-password" type="password"
                            placeholder="Password" />

                        <button class="staticrypt-decrypt-button rounded-xl bg-rose-600 px-4 py-2
                   font-semibold text-white hover:bg-rose-700 active:bg-rose-800">
                            Open
                        </button>
                    </div>

                    <label id="staticrypt-remember-label" for="staticrypt-remember" class="staticrypt-remember hidden flex items-center gap-3
                 rounded-xl border border-neutral-200 bg-neutral-50/80 px-3 py-2
                 cursor-pointer select-none">

                        <span class="relative w-5 h-5">
                            <input id="staticrypt-remember" type="checkbox" name="remember"
                                class="peer absolute inset-0 opacity-0 cursor-pointer" />
                            <span class="absolute inset-0 rounded-md border border-neutral-400 bg-white
                     peer-checked:bg-rose-600 peer-checked:border-rose-700
                     transition-all"></span>
                            <span class="absolute inset-0 flex items-center justify-center
                     text-white text-sm opacity-0 peer-checked:opacity-100">
                                âœ“
                            </span>
                        </span>

                        <span class="text-sm font-medium text-neutral-700">
                            Remember me
                        </span>
                    </label>
                </form>
            </div>

            <!-- Wax seal -->
            <div aria-hidden="true"
                class="seal absolute z-40 w-10 aspect-square rounded-full bg-rose-600
            border-4 border-rose-900 text-[10px] font-semibold text-red-100
            flex items-center justify-center text-center pointer-events-none
            transition-all duration-1000
            group-hover:opacity-0 group-active:opacity-0 group-focus-within:opacity-0
            group-hover:scale-0 group-active:scale-0 group-focus-within:scale-0
            group-hover:rotate-180 group-active:rotate-180 group-focus-within:rotate-180
            [clip-path:polygon(50%_0%,_80%_10%,_100%_35%,_100%_70%,_80%_90%,_50%_100%,_20%_90%,_0%_70%,_0%_35%,_20%_10%)]">
                Merry<br />Christmas
            </div>

            <!-- Envelope flaps -->
            <div class="absolute inset-0 bg-amber-100 transition-all duration-1000
             [clip-path:polygon(50%_50%,_100%_0,_0_0)]
             group-hover:[clip-path:polygon(50%_0%,_100%_0,_0_0)]
             group-active:[clip-path:polygon(50%_0%,_100%_0,_0_0)]
             group-focus-within:[clip-path:polygon(50%_0%,_100%_0,_0_0)]">
            </div>

            <div class="absolute inset-0 bg-amber-200
                [clip-path:polygon(50%_50%,_0_0,_0_100%)]"></div>
            <div class="absolute inset-0 bg-amber-100
                [clip-path:polygon(50%_50%,_100%_0,_100%_100%)]"></div>
            <div class="absolute inset-0 bg-amber-200
                [clip-path:polygon(50%_50%,_100%_100%,_0_100%)]"></div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Bad password!",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03ee97fb64e7cbc50524eefa6de5081711cb6239e746ac69650df4002f203d43cf16ebe4d532d1b49bf0420e4ef1abef9d62db2d157b8ab1c1fef3000aa4c033a5cab2412d908fe4d681edabbc35fe8ea24329f592267236c799f1fca1fd4e346ac4bae7fd04a4a344659b5c7decf16144d0285791e7181897211bc6db27011721283b0f95c7136486a2ea5558202b0418aad03e08006734a7a5e79b59f5796e63909367d0fff62c55dbb1a3f6007f9c5ff8f6df8715bf4cc1b884318ee4c635262ecb1d675f57849b985bd061ba7e4774d56731e6ee4a6b3c9cedc3cd45572caf1a68ab9c0e9178bd916f42b347338aec7aad0cb04602896a523a4850e419db9cda5b129e645d1c509ac7cf1f0e86958a35d8d57c7387b366d93a3a895345a61fa6eaf8b56ded0da089259e5eaedb82e986ef790efea45f385adb657b9ece508aef97d10c2f88632038cece54cb25178665617b8f396ff98ac8a851d8ab8b83fac9ec0f1925b0b92fe1e923e6c7e52f937b5044dfdae9ebf97df12372c30d1e6f4c1ab8bfe7098f65240ed78faa1aaa9261a172cb3d39b377b600090063fd4deeadebc2d423d66e3a76d7a3077db9655e0b86b16df5f7794efcc5b7f6035a9b7f616f5c0d1a032b19653855b320b298c8243ed33d150a77e9dcd3a20e86f473ad68c2d294a30c3caae815eea753dbde23a3b217e6f508e6cd1dd7e12f7d10d188efae8fe7b750effa8b7b6f60c6debb67152765c8ee90358d1b1d09be8cd1be2322ea1c4877d7a4bca4f07a45bb7d929b456b51b48122c03d18e30814ff92587fa9bf66fdf4b4b15c419f98c94056449df90c07620bf936cdc54efa47203c568088877a362f8abb5800762819a050a1495db994de473ce040867e5ada108bee34e3be94eeea62fd8518911b2fe1d663dbed0967db9b49351e73962b15ae937b3731822399373c8889002fe266a4e0d20a4586173bb899aa7c9945e0e74fbe3cdafb9ad0a8732054417307546424bc0fedf269eb0516b51573643aec2cc5bb6d57b4b6518ff75a94eff653f8da1d9e871f094bfa2287b1502026b59e751b39269ea2b4352dc517fe66f26f4a0f91cb347bed05d23a5ae28dbb1189c61a8d90a8ec0e58976248cde10d2f93739e0502c34796cfeeea3fbda66a4805650b00e3f714edc2ac6daf9c2db5bab68174c257d02ba839ae571350680670be77c03b21a8ba94ecb3adf5ad3a9c62314d679e828801ff2af7ccb58d2eec447069f01fad43cc1ef898405864994e5aff5746a40d7b0a0b5301aa1a4a85f94393b0ecd7d05ec6558138f7ca1a6d0164fefb43efaa6f6a773903115c355823901f4c09a1bb56bf9810e263c8912c59146d03a704169e230ba0a44eca4bb9ae19f01c42638c469773d078377077d353817e83ec301e9d74838bf4f78fcd4d13297909e4e811e1c88a675889bfb143fa3e763fbac41cab65c4e2399e938108e26b1c10c302e56b8faafdb99e348176fe6cd87d42fe94a3469190dcceaa892387ab130498a2f5da52c38141a5f6e5678529e378e04451cf526706cb9a486ed050e48302d34dc0217f8b1af00e2b11dd9fc8aced7334c3ed1dc775355a8673df1710990a463bd11333135abf625613995c24a9e8855968c042a7dd6deae50a6cfaef0380014a2c7ce0d4302b4ef1724b51d55cfecfda733e2ba8fde6e24a0fcc4a5149f790279832eac209e4c0d27bf70616607259c80160ad37d4138a5459c9bc48cda4982fc01fdcb596a632124cece5578f6ab55345c6fe680b1df300786c97022435c3149d278a0e139b68ec29ab5fdac3b5c02d161d8dbd86f7f84bf3ad22aa274c43e41159531a2505c552e5e0d779d9f254a8f6d4143f0054eaffe678f9fd03d98f46c36c968759204dbe52007dde052cc05ac85901b1a4842923fb5d2090e9fae64a86baea0b2730f41b91b33e989b3735500bfec6c2bb48d224a3f0337cef323d1d5621cfd9d2a85f68547e8f6f09177714014270504585e8cf753a0304968aa34660b48fc86b3e8a0a7a3f343d85cc434525ab84b6e84d739a441795322e487a214e1ee40ded6f55f08223bd538be3c1bacc6ed3f598502909d9144ed4be2a7415d3d7ee3595d00f475e8c623f82513d238f96b46fc88313bff18e816765c03371a4ea545cb1a4404d3d2fa46527751ce3f974ac5f2f7121dc8bb9dd78176b2485396c32c7ec883759a1566623c226954b563be10d93ef2e90f69f4c958c70a61e5da5324810efa7fcd4f8eb63d2843702edf8b700156ef407e92a0b980db8362eaa8ee4b3c9f8fc687e58d180e47f2696679dfd4dd2d3f97c23f63b19a2598edb050d1bffd54de467dc9204477e4a50b63cc1e4a3022732be9d0e85e8c5401b6cf3adf49063ef0429374a0d70cc36139acea91ef995f1e773e46cd4992e0d73d68b91117a9b3cc52410baffb751b3fbb1c4c73c9fa42e210a09c638eec7ca7449660f1fb2779c870946c8733891c6cf7b83ce6bd827185ad9cd078e3147044eb3d62e19e4bde2d5cbef6979c59a276e2fba23d3583f093c3c17cfbe1ef91cfa4f98861f71fb2e014113bb9153099ae63472ad03f68efdf92171cffd1d3d121941b83b10ffea046ee48afc1404ed21f9c99a3978e1509554fc08fbd4da3bd459c8775653708a357a402531567234fda668a3427a63a2488b1df539573e0738e84c7c5b1c8cf20c822b32448b79c9a68ff459972ff1e7853744dcd2658a748b196287d328c3a4e1c9fe2ee8d48573498979428e74626d66cdbd8b78badbd8a96925ca1ab6d2e3a5d4f4052f9f6e7c3054ed48c3342dd7979a5fa1bf11682428c941b2498001637bc619ead90d45106adb0b0cf8f45b3c54aebb5dfc7c2f3c622fdeed65298ce7fdff844fd02f307849cce58b1781d35fdd851bfd97b6a972849e09bacac91d20adbfb03cb6af1713c891a51c3386e679ebd9b10d362e521dfbaf190297391e707d19f50ef73085c00f960c2279118e449078555ed1144f9eaa9c5cccef4a09c9dea4a0907ce53c8ed47f2d0b21a6db45705a65aee6c58aae47a278df324e2da63e1ab9dd96c8f9288185011e1a7e06f9fb91c7618e21d091cf0f72e5258242671f269c1726039ecd5d67084ad90ebf9bfbbc9b153694763482ee1e961c56528e2e344b64904aea24e5f71029aec1400394a100bb46ffe6329088398b6ff7ac5d676879907be2cd2fe19cf9fcaca5591eeec13770842b8a983ebbab55190ef6aaa40bfacd5b4c49e87871b7300d7354276ad8da3ce785f78d02dbfbf3c5a0a72e628014e64c1063a689f872f214d49cbd0fa71f08450bcdbc608c0771a8d02853a12636f15958f683a1f6d73916ce8e83922b790d7697607873a9199ff51e644de5202543c847954d813221840ee1fd13b0875cb6c02cf430e4d4d6d9a41be12efb97010e2c90291b73b6749dd346d87035ba3186fd82f066779fcd685316c114fd9066f71f0280fa362b0a10cb6796325a0137f099897898d64c702b1c6edde5983835836584ee739ea564c0f20069541e0f788d48ad8bb2258692412285211b89d7da93f921109f9fdcbd69e59d7dedbe80d4589f0f73a61e420c0736a18bf3e14b19ca0e2176bc7cdf201fa592d7363d47a3f5c7daca0aa192037f2e53a0e9f06a8d04a6070b2755321e12b2fd828608839c7582fc64d6b6660ea0758eed82ee7b7a6c5af908375e44764b219c14494c2e8905cecfe684b6fcdc6be6ec4d266834aa0918acd48258004899434bc6cbd6b991f9da217b2391fdc9ba2d86e7aa4396006766e11c5cafd743fba115a436feecf22cb75a1ac4e274460a3260c5bbefc89c0b882c21fc86e7cf016269fa8e584a3c9c714380d75ce5f19533fb4aa51327dae60f35e95ee67e90abf964c44688565bf6aa492c1d095f1313b7cd4ac65d8e62c89d73447b2e179a64723495722747e3f03c6d3aaa7bf1e839f4964722a7cffd526eb564466a7d7e12553b3785771b117039a656f01826810837d97ac8675c4053fe0f8ff72ce8751856bf5c02e19d4822b2748b31c14db2969018267582545b4fcdb8aded55ef8121308e47f8f2ce2c12c6e99a43de305b6baa8298ae81a078d5d19a4e9f4e46ac2df72b69e4a5e9673429bf5a1a3f952a609f7e0a940c1431813fddad62382e06a5c8713f6268e70db4dd7b674efc05f26c2b88b74ca80668a4cb4f64a6838996090116a66a91a46ea211c837584959de84dc54a10a5c9c1a4b0294be73c126ba015a303962fbf61bc4949915a6f59203a863b6f2f84c5a289c9e27c6246390cd0f82aaf8d4598ccaf6733c0b65f5eb935c1c1920507e3904e499c4f5360952479403c80fbfd4d3600c92cef5fe9f5b79b048d1b52b0a51970b71be11a6fe457f9da903f1fe876bff20f293b547daf9fe4326271bc520d39e70d84debaeb61cdc5a4948506944e162684f5db1216aad12517f7c588da2df8a174602a426240428e15d6e4b188291be7498e38551bc3d56c91d97828687ffad971306011f0ac87263f7dbc08a4cdd0dd52c7fb9a24d968d5e1df193d0f0797fedbf7596cca953ae957338f4e6659be1288e7c991d0322e561a1b569162b29f291e68fa17d83b3d4aef158749787586937350bf53468e86f1c1bcc1e0935b1a873c96fe708294bb28ba48bdf2cb02f4d2debf9b8a05e168f18d80de8662cb377623105e5ed1b7b3dd2d3239e64c8e32065e17013a5350ca17ea9ea2fb93db564e78f78f4a40b0a7ec09c77543ad916e677e0f9bed1c32a786baf7ab12ed229cb557d0ff6dd73d68ff7d23c46d28dd27c1e050c24f22f079feb643a40f2b0a00219b95f413ad8da92e7b5cf9749da89c9752bc77f37a065d87266278537bef5a37daeaa3117bb8fc57d0bcdf2baee8f5ed367e720acb0d2a9332bcea88991c3b59a778ddb65670152b6da87441a837afee2bc9c1effa2a76385363761aa5dadfd755d47af924a929a11341f3c8940470ae15f2732e6c21ec0a6c5e9b0c1ce4fde4f28d828032ae6427e0b379edf73199b0d9200aeb06c541a325e31930898288a9eef07012c3223d89357d019e272b985244b3328500c4133d09a7dcae5eaaae48dae1c9b91bfdd2a91fd9ab8e5648a632c048bf1ae70b7a38d617d32dc07e477c78f9db80b9c08ac233baaa2bacb8888a0462bf8e2c2fab93cdf5a3db2c51983849b565d8b456b3a2e18864833e04a9e9dfa6b6b3aa4d975b2137e741563e4eff730401353b26551a95466c9b26e650e05e5de97af9546cec411bcc9029202d26d8d5d84f872b32fc454c2dfb5a43d9e234c240dd642624ce14d516d916596e9e8907a698fe7ab61deb18596fd52fe0c1fa9c7c4e87c3da741f3953cf86957644fb6e64cbc32542ca28ea5e3d040cb211f10b4a85b999cbee654981195314d431462e5dd10e9ee952eaf25c988709c255453bd3072ba77a3b1e37dedc295623c83567adf32dfa31b639055ac3402154c6165edb5c58baf48c8d6d32ec0a55276292722b9d946df4da0e957b42cd689b476e9c316a1ec2c16cc5c4bfccc0cef1a63208b17c217ddbd16c7b7264eea9c5c6408bc67d304be10fe0cc3d1e245439675e6176c0d33c7dc52cee4db67d63aef0f3d6cb281307cb86c07672b73868b67e0cbf9ae9aa670e81c0008aabf6efc9a5f9cb8e501b24fa988d248349d52eff8f807d3e63ffae6b0bdf20cf16bd9aeb6cfee8cd8578b72e41daf4683eb7eb6bc28720c8b6f27416774fc4941dde16a47c02e28696911375fbedb3ba28a10ad5e8f4cdc4521b500e097af08f19f53b1557b3cc3560813f0681ccc7f79a6241dab55766cdbdbc6f7a6ec851ea482f471808351443eab089f751a8dd20b3d7173ede58e297bfab22476a990b1eafe4857d10e0a8dbcf8e761c27a0f2eded6074b24931f3a43a64bfbd443b1b18f4c95519ee0d0dab4c5c0a2f07266d1fef8b29f061770a58d9712c6478bec63490f965673e96764679ba2d2e081a8419ad3fb52dd0028d39f3bf2c04a76f79b762d717fc265d04f609bef7f424c7153edbeffe361e1371678597bcccf00666be26083ff1e56e0001d1cef0082f1184e3f5946e61afa77dd8a85168edc7f0ce077bc72af92f7dba629931f87ea25c2fe9453736b28da74cde957d7c4171ebb9da6fa478ef9f719e72d0c63024f7e1b4c67a845a7b8e5b978ad8a2f31af84204e243a3e8e7feaccb3c025a9f1d7ec40a97c24123523c4807a1c304195615857973b9c0ea524b7a6bb27557509a5550166cb9e835b40a272feb11e0be517ae29af119c9439d6402e5b499b424ac6cd864a0a8a42211b150f3f63d472b2fe208819857ac36b6763caa34eeac0d084f69e856df65005a39387b1b0d9c90ba3ce18a76e5534819f2272fc665f24abf2587eea294b6174b2b2fd7ca11fba5df1c367bcc0d1e3617dd1f9b9759857b66bd2449ba4a36a17a1114724b30f109a0e6708ea2b107c63598e7f25bb49bc91212517279bff6346e2137b788b03ab3ba35fa9a5207a7fc66d79c55ee1df039cb718c016b9402e8fb8d4fc57068f0c36a48ba7431f7aefd0aedf853fa49e8c22a59808be4b9730c5bda38fd1daec11c0b0d1ecccb7b3a9061692b9fb697fda0fae6995980fd73dc2e5fd2b5f329c8fa26bd2916cfcc6d13d64a693d581691d36be6b7c22d0ad6a8306ea839ef8c62360d0985042dc75b49e1c4e2d1ff192ff45aecc0c73bdc5a60382c6455b2eb059876106127eb18eec8bfad5561430a2754d1f88cf28fdfc9e14758ee4f901ab2973de30d44ca47d28f9087dd5ef40c3b02b4cdc21e68a15b532837bd2046036551317d6e8b625d76f64de992e0a9726c779eba0b5b8a60ea53afe54c131459d02b67777386405c13417ce7c1067cab84eaa214ce57963f61120214f055c26ef1c5673635dfe22b5d1aef223e2b4bc20089d563010290fa3064f18fecabe45f5cafa77f7efb41729a11f467bd82dcb00e5e997672d7e25c50908132c0d479b673c33825d1ffb7c71b2fe720d2c2a991be1579163ce03f6f6eadf8134af00fd7122df033ff9ecd6c10b016bf8929768a6f23e0dd4611e2f0f4bcfeb8e0e4d1eb53f5b0b3dda20c308bf503a41f9e2c98e0eadba9426c32873cac212632de02609bf94cba15d0661fbfd687ac79522fe4c9db3df4594847aa03ec780f28da4ed1783ae5d8342abda5ca88e36dc41dcbe24b8f4b4e948320022e120ca6a49de3a43891263914660d9d9bdb192643296767ffb8e84cb2825c7b4baa8ac26430452470c5e4d04c879c63bd8c568f99746708c418ae0c8765f82f38c24eb884b1153021f6a3ad539f0a963248ad744d17b4011ec769caf7ad984b57a1de612b1b10f5a2086987e9282fab52cff947dcf2e0cc4c72c1603789373b5a318f539df04454f93bd3f6f213de1b6b5d198c3b2997802b201f3223329c489d13b7276c3bdd31989547c24f5625c405175cc1ff9eece044103467eb48a4691dd937dde78a4826fd555ab20bbbd32f6f3728991415325aa6a49c47b13ff8572b7d2f9cd0631c0e7f7d0974360b6834677edfdca957bce38cc611615f4eb56eeb48ae126934569223915d812951631c3f5561b0fe41e597af07d2fb506d16e75de5851db75f6a1b46ad9e08a0b98f581d46aa8e6727367cf54af23572113b3fad70837537a68af791be3a8f0a480fa00394b7bd120b2cee1b6bee6a1e17bfe74c36c4332a9cf913553ae879d5ff46d4496aa23387fcdba1dd9a1aed99f4c7c48012bc34fce5d5e0a4d05f8eb38bd09ffdd3f09f1040d11eea0011035fdb350fda631004473001925cca4026257e825e5123055cfe1180089e57f973b40fb7a89e1c5aaa359ef4b9e885831eed7c319160e1395e31d1e929656c0e298140827c781617eca03fa16dfd840422d04122a4cc39e7e27977eed5a3f5e2f3cfc6b588769b8814a6af14112eedd4d93893e4eb065532d2514c9e4b2a68328bd76ecab7fc87b8694a98cfbdac584302dc089b45221b3c22585e781421bca901b99149a8cc91a6e2727bb6d742e9fcae00ff3f9ed7b3436743e5b6352c1add5cf4441e451a7a1c98d4fbdfbf1959672c8ed281f9dbd821181fcb611a47ae24fd15e43854ccc15d273ab468fa5543303694e89d188972e453bf2a3507f2da6c66b4a440c0d8dc24ad5c4018c7ccf84f72b119c89056f551178c3d7658dd94651534b5959ae3c4f1a7f126d43e7af31dfbd6de9a5e377c80db7c940e7fe41390a2e1f78b9752b56e7ad3e17fd712244622b85c87fa77c2fd6e21023f6ac9fc04ed4e09e1eb1e9f2e4df774b06d8d3b037f63b1d612be4eaf74be0a01efae046c95c64180a370af1eb864936741fecad0956a8ce95bb201272526c00a03eecfe3ec63b40cc97c8aebeefddd5dbd70ab8f43180a30ca268d9a46c24d6fdafb6b3ee258d8e3e52a3601e5074b80d25774ed91a83856949fb23680d56f073adc3f85485fabf94f4a06edb3ee0ae95ffb9858c1b43e62215e6135482ce14beaf281fe8a15685ec8dfca4e34edb96e4af59a5adc54ffbcfad930c9f7b8010a5c2070602807f8a9cb6b884ed168b61a6c769afced3d1daf71cab07254547130ded2c33cda499941df0142f16bb371d4a909030e77ef3454099597befc65a93e8fb068019fbf2417827779079b46e754b2f74d46a2c0eac183c9491d1badf880c8843c3fd0d18882761a9f391bf4189ef7feb8f40f310081e64e11d56ee242b526066549fe4f76deb8390a52264a170da06f22c82b11acd34639cd0ffa619ce98c26f6829bae19678695a44e449cda323cd2ca176453e6cfec1f3fa143c31f54b1e156a65b1105d70691521ba226141ecf1d9bd15f2667bbd6247620123ca594807896a403d48745f19a2eff3754e49cd49f6e752ca92344231f3102131b92b6f008e2f02a16b0ec34b81a0e1836d1ecbd45a02f053a024034c64c500b5a932134652efc5d52a40975d030687a3356e92e78feee6b8bd4e7c46853950c83fcd25dfa0eb60c7f732256eb607b0e1959d5f859c091c796a1c548262287d5fca00260cbce62ee62ec10dfcd890354a4d56ac8943f05473c53baebe3f553b6b9916e99cdc7773e04797b13b1924c6be0f0851fcc1110d23575f2dadd490efa29efa1ee9f7aae46852d8009f17cca241c0debbab7f770b9252857429fd8d4df194a2c5da5c472c198854d09aa02eacefd9739a66fec791739bd2e77012d1733724c98f7d21d3d64efb5154d0056333d5e5bf355b832e164a30beee720c2ad6d6da59548ef8667418aa7305eaf0918ed306f360c433c6b03a61d9b8f7184b9d0ed1f7a1dab0fb6a9eed1629955c2674010417a6e9810ed44549b7a223247383675d00e3b20e00ea5afd3e08e34219a9de76be4b9d7f59135cfd6755c954dffd900951f2f93b5d4bd8b4b61be577e1af2e36d37be40c7da5f5b8475f874b486375d7895505511325d8946c29799330f977ab4f104299d663d9d57c054fb9a96e8c0b2bb197e4bd679c2031b97b4570d1473307d61fe139efc55b9926df48163571ba909525ab58e6f4ac6a135c6a92cf7b3932cde51ecd3a9fad88b0a79d828198c8d7ffb26e8a6efc29d9ac6958fb9cabcccfff0001754829047ae66f1fa509003ce534ea6eb8a5464c53197af0838197b76e061bde6092d0ea39e9ba12fab5dd17d0e2b0d06793a5c5fffd637fbfbba53fa0aed7e4833621b20dfc0f3b3645581fab405085df47528902626ce51dfc2945327d9be634cad5787d2ed7bc941e86b6bcb8dc18c6970afcbffd35f53d1b6ee31bda3860b21357df664c28a255198682e3c837691c78bf48c7b806f66f4ae77153f93b4f9b691a2b6eeae5f7c5b838e377f124c5ecdc34e1015141e583104564c4973cd35c868fe2a41d49949ef80450f11a95ae41bdf51836e477d07d2fafa6fd718375813c8fb96e3dbd5a78525c32bb7657b8171c28f3562ea6b85cd05953b80014f108ac7bd33b9866a3ed1296f3ebea5933855387247868f9e6afd8777e2633a2512d8b089c8a695e5ffad2a211cb521a9eac98aa34396d633eaa6f4820347cb407e42b79f651503c5a765f86df6ad34f989cf7a2c294cb596bf0dedaedb1a05f79ae64d04fc7ddc2867f443d73a49393f0edda83dfed17fd343ba531f375eb434bd891813a79fbee39f527f3bbc58bccce6cb67043f5025a24dfd0c161b0327916e4f345dab858ecead279ea3739c02ea956d387ca975c74930f3832ffb975263cd13ba8135af332d5346828829382a0acff56b9ab76b7fe622faaeca4ba5f8dd94afe6e64ee18ffac85fbd2494170c3cb224a41d6e22e57018e6811cd07186cd4758de382dc8fe2270fb0a3808910897a5eba403e2c7b881aeede9c2ab457b3b87d681aca8f802a63a20d26fabce0ab562238b2a31632d77dd0cdb8378a09a2722e3e8094476a0d634041b3a6bb884d1cb7871ecc4095e9b22c0861cc97582ed8136782f963f1657ec0538dc3939154e38625fe3243c34489e4f61481ced579e9cc91cfd331217d68a9708649703ae1847877a3c311b48e6ea10b5ff5f33508c811b396a03f0808b6bc235c4ff2448b31b33a08d662ff7318e607449345b0e699a01764f575d8f2d8ddf1ee0a84f19aeacfb32c24bb381ae03e7241996a9f28ad8182180207c54703edfac103a720f603bcf3ab3d692026373a4417defcb7e97f747548419f3b528cff0d6dfe726b6b12c311a7b24849d28573033de426678911023784e73e7ea7ccf8dd7c6c568a78c9a3dff225daa91d539896102808c8ac43547bc907b7fae0ebd47307080736f4b9174e2fdc58311f7a3e16997f0a6f1643cdd3d89dd71d9ecf79d2df067010c3f2f3f7584f1513474c57c69517aeface22daed242427af8e86fae4d9a8f4c33d695aa858cee12c54afd4bc764e0a9c9d330cd02d0e096be62d91d6344a34fab2d0707432e028633576694599a324f89d5f66a78feb1fbecb8af82844169a69b41934f36aba667c887e2741e705d634d8c2c25471b5aa7525902f06e5b708e1bd0a9228f1b62acb23380770a5696a53f97d800816414f094d61772e933a1f0a89c67675a99fbf846fab81fb38e13acb3429566aef539fb9c96510f222c43cefccde2ea2733281a22ac2592d1e2f2810e213db86f6e79579d63ccaf44d58e00e04e9b6cc98486f85c2b0b4b33bfb3694240c304834c29259d753674fd362960c589125293a395181a548a93a469e89c11def193b5437094be0e6a6b941597bff3da52562a4ffff750b8ffc9a0b8bd0066262866d5fa6e647f97377ff75fb018a0cd6c7596d430e454a6d0353c56290dcfd1660b8b1131c27bb893a51ac3fab38e4635a59c229da8b335f42d9fcafd43815fa8d5afef74adda5c27ca2e6741da3464d7b344b67551a83ebbdd12b238305d7e3b7299f5779c124d3e79c880d6b31f1d15ce78c0b0f45c85c3cabc665c81627205fea38f15146b98d4fff9eea78cdc35a50e7828173ca348f19146098da91076428a1a32a214cdbcc13b6352c8cf171a86a9ae6f1124025c132745306d6a7f0d85aad3b4d36c1bf9893526fc64e1c8ff7010d220c7659df8bf2f609ccf6ab495ecb2fb536707ff23fbfe6cb2329aad9aaa2c6560b5e9f522d457f8414cdbf8bcfe1f809c30547062e89f9e44adc861d184568d9b8a3fd4dd27d1f3dea6cb2ff981510919d7e686aa9252521e7d0da9d2103c3997e4d9963babc417cc82c0462a906e86cfd7a77b2d4f8e3447c3763272bc7e7f8b9e2937e97c6329927a439b3b92d33159af927c33c96121c3702345f5ca854920f9aae03c10db93d5b39a15627adf997b4bda289b02724c253b9e6220cf954464d0d9419d7839a33aedcb581e4be9174117ded96df4e22a26500bb46194bff98e0479810f9cdd353a544f016b2549f75e6efff08e9b9c54964a829397d9c88bd6696d8d0e8ee9fa28f3f2d95564e854b4d52b628492b14d3919ebf83b9cfd5a05f178582bad808f4026f69a6ac49b5519bf792e1263f01c805192498330127ce82c5e67d17c3f6151a7dc49b1429d6845566d4f1f536f6d5f873bf9544a6ce15d5c8618cd8bf72c2d6df7905548409d1579a3744cadcd0e841183fd9d523c619d9fefbfbd32ef84d5723aba84ad2baf804fbfecac4739287107b314e7067901522f91c88963fbfc4adb90d08e1e07aa5021dfe30f567dd560a29d26f2a774cfdb3e6a26d074edb3a3a9d3c1ea302d7014e5b8ab45cd64d14eb09eb29613f2ce095dd0fe05fe0e78650619869876465aba72f858b0034d6ead458db8b1fdfdd75962c648cff3e302e98b84db0dbb36592f9a7492df29a30f0fd31506fd399aed54238ff683018621a0a3cb90f84462d3cecb08a563a9781d3de00f7996c7f77414cce09f07b00cf95bc48b7eb0b717f17898e20f71993420fca0dc9bd9ef7444ebb81b2b3779b78cbefeec365aea9d5318eb91189b4ce50d639e861d34e97e2c5933202224f10630442e623113d3b53bdd562ffe74aac46ab21e005bbfec7b21bd0c3a26d60f3de67161d65ea374f1878075d62b68c0102121f65ce9fca334469cc37c5fa429d9de5617e88b04124c40e1f82341e9f4e293ef13cd987ad6080472015342a3b55d02faa483bd7eb8f0a13c00e509eaac438b1e97beb0eef5412fc096746825665f3772653fa4081a89b6fc8335f6a15a148d3d0e8128f8a604186156653679428bb83a9464aaf5295b1421ad1d5a75666da6cbb9c144b6bc616b143ac31a0bc886ed226a2a9a3d12a51d7b5a355f368a5c6fe9ede0cead0621f17582e62133b954b1404e90230c3215796cdcd6f75f5aaf6af6629b289fbc3ad7f3f76b3d610c25707e7834682221cff80562e71428570b6dd733ab30accdbbad6c980e5015b184e914702b4a53401225f5a25e5aee4f58b32e31f622947c308dfc4b51259f4f2b20b1108670ff166d2c29648e9c4abb4bf96351f74196b17c2d0ae6f3753510bcb23190e86c355f54494cf268d2f1fbbc8b18ffb0144edd44cf26679edf6c82b157bb89c3e2bf054defd83f7a5f38148d591fa7953ac85a639a6fdbe8669e87c800170977a76b6ff7329b532b9e3a2dbcd532e01e7a44733efe0e6714969d6cd9329df52896a04e91a9a499d9de39299e3a50ad86bfa692099cf3cd251154c51f5c9f9529eb548557bb603a3b3feca1e68b4231c5b81afe3e02b27502dfc27fd64a1c9397ae7160f00418a0937ce2df20d268ecb51c3b241d24ef1a5c0bc1d5ac48ddfc3acd3a9a7776cb76c793bce2f914c73dabc780bc9c485024fe41bf022a222abffba1be69ae43a33cbb0cbf013001eac435ad2f18b4a97437f1bd95d41be984ee0a40b3e9c0a0b91e125a5ef39a2a2d0070397172ca4d861b9482d423c5dff8f18b37b74c3b7b18367e1daf22c6d85790b91b8f01aa2b64e15ad631913efaa03c9f9bef691270931f0774c6cfe3806886d660d64b1d52dbbb2454e32933f89f0bd52f576058fae1f0c53a321bd9a1ce91be732d151199848c0529bcbb17799bc54fa9aacaacd2cd2c63d3f21ee7646bfaee69c100258fb0c2a2ce511ef930b64967c19af298ea4e50977b9e6acda70b8e661c1a7c327df8d1ad6c5e378a7ceae59bad011605ed08011f600d26bd65af8f9af9ea7054a9123f308963358b673196439755da086e7e74d61de70a65e0420f8fe48e608bfb89b3fe9321e837968773ad8ce4266031af118855c873fa47e9af7a36dfaaef38c067d0195259dbbad0e8f437703a5df3b3ffa2c0fade9acd77d745d9c18d6a2d81b85a4b72d0cb9a3929edf4bc9d3513ff6cc42f6e1764a9d8a3dbfea00d55cb9a5e379acff644cf2d24266722e97ae6641bf5df934ef4c54b043d79184ed9ff5dd26c7a42c9456aca78b5958d80f640ae87a4cbd1719b380d898bbf3e10a65e3a6b5ade0b76671c2271053e24f0b72dd8d0d544ff5ba51a4ccf4c91db731bc64ae17d6fc78954b7c24e5b518e8cfb37115ff1d045eb6c380867470559bfbf9f01cd36dbadb4371b88fc378700de3fa51cef7e28eb421083340dc0d28c3e0818a96d69b86738f9b4ed0fbbd9dfdabd684335541bc7ae7165d7c29bd17a01704edfcc894ad48471b42023458518133051cca778c3d3bd0b2aa4415b0b717d46345bf9b3a32942b0a36eb7cc679362e5668131155a2f0248b8bb986607c4bb757a82eb8e651ca52eed4f9f1eba50cf016ce29d56f9342ee88a54abd25fa146a99205e12597e9fc635bd7e7911801c74e48e4b369fecc2333a3d22866a23aabd0a89383803f4a373ab9bdbad057b08ab4c682450f76722d64ade705099c334eb5ad2a1b8115acc597bab314a01b2bae816274bd7181341728bebd406881cd9314d9ea4ef635efc529cf35bf9bb7e50e20cdbfd93a01b74169a73d02363e31cf4ee1702165c9b9f9df0b5a53835afe248aa4b032b73821571e48a0bc3e715afbd7bc7eb5019ceed8da53756876a06cfd51cea1884e432c0e4984ddf6e280f1c6d96d44f791166418b54ebbd5ffd5aab907326983e0eb1186b7bac3f0d99caf96e67ea6a156cecf018b027d5de7de7461bb710ace08d6124ec1c74c0748f704c45885b8e22523083458c030086cc090c197051efebf42805724cccdd556cab315a61fdfea40a06031a30f11f1a5c9896882b5ecbb75b507ecada13d42a155572568de38fe95f4503a18690d1d12e20674b1da76e3c21a206dce6825129a467700285b210dce3d29046ed1ad1cde99c72f9b177333bfeb952526e98f1368582eb4718dc293012570b77cf227cb82da7fb6b41cf5484cb261a70972da19b6e6fb53b6213ce620dbd94a4467de890b99c5ac424465acfbf77c36d99eff9345c44b7ec404dc9f5fb1d3808638d7abd6e857c81407b5ef560826898b23658bef501fed6754003cfa9a02a1d44ff2e3cc014f504f89754638a22af54d183479231f37b4f9b72f1fb68c1f2bc1234dff4f58e14011697bc61aababdc3542fbcbaef331852a88ad496cc6bbb9e22423963d8d16caa59038d1756688092bb61369417749d18a59d5f05b2ff10fad8afd6fb638b05344bc3512482e56ebf031da7f1c48641cc5ea3a91a608f1f2c04b77662a05d6afcba23621c3ed0b3c7e816127a22dc3b4ee5ea05ee3adca37ebf4618a09a4f08d17aa437d6251ced9bddb92a26ae74be09d24b20f882a2f9fc21f18b1e76241b5abef97e9fa1bd25617c26ee3d9e689eb835ecc1ed4f9103b9342d27c9f3036f0ce671c94e07004f86d9b3cf8680fcafd55ae3db0f41e1059cdca61b0c0a5509120537e2a8ad173e7e4e032f72df6bb1f515f7642e8024a95d1c3fce7cfd865a0634122615bebb27ed3b586d5b0d538d5c2e16730bd933aac024ba503f8bc92bdc10f3aaaf993bd18a0070149aa425f5f759977bdff238e0cae6e6cda632063cf9ae98abba010c012bc4ef9c620643f37c76235c32eaadefdcccc26386dc13c09dd8f837b8ddd8508cf2ba74021cfaac019cefc7a1d9062ff96be90e4f7255810875120798dbe3ed4788bcc0035bbc9195a3c8f165ffe2d2906803e179f560610e16e33fd30692a6da07f9a38233af4c9dd4118df0d012f544aaab4609457b2ec4d5086c5efce883fe0d5d54a4048909e8a3273dd40bee608169c7d4b273b0d34b030091209dcc0871ef8cfe337b87743810818b17d42c4d4d31cd909ad3e540d1f3f7bdd0d734016dcbe8c110a5b8dc37c6213dd755da33276747b84fbd771ec5c4979b2a3ac9cc4aebf453d40d65b351e36d848e59fea4c16ff23a25ad5cde9683f0a379f8f366c0318dc362a04fca900191145c0bf5a35aa057f2e53020edea1189a4f38f1aa4b30d8cedde979f36099c947a89eff749dd2518bcffba76307ed7de30158a4ba56b37eddfbf60a85d7b42112239ef831b2fb1569143c16371c8ffb5f6c636294a8e027cc7b673eb73c324fee150b7e637015f50998ad596852616465344f0423c86629830300d54159b00e9b05cc69c712fbd31e61e5135d864ced5ad804aa30f8a9cd7e7d2a59a2be07a69ffac58591d96d445cc9d6c64bfd94c6ff9db6c594d898b29a48a883169ac35deb913d3c51444c68ea660c120687267a470f6573c10f776e4263b6dda02fec901edfa6dc529a4f9d268c3fe0d018bf257b9bd47d60bc4b3bd7ae81df7f173957d0662caa1b69868d0c31b59b6e9603f059461acba79b68ef7c8bf6e6b09d4946f0d1930bebb7aef8e08f588e2acc66e5b5063b5acd45034b3692b18406eace34ea2d100fe957c86114ae291cc0d5e6596e33f0301eb281b3f733248ee4aa3833f1103e585886ae305744aa30dc878b9f1a91273aaa1003e0f6f30793c9c3ecefb4dc4e04ba338ae5d917cc3cdabfb5fe247ff2cb0c0e22a9bf6471bc31a5847875b5c529aa7fe8f419129ca45478286116bcc3f7d010113797fcad362bf642f149b4645e5a0d8c8298c06500cf2937463e0e907af3d0477a2f388f52be34283df1ed75c953e88d5ca232a47752a7117151ffb72134785143194ae6b6a79513604af4015c9488d24255066a3d222795f93754cd239fc6630c540934660b92413b22b6d405fbc25ab98e9fde8c8bc600bd6b2682d609364e11956c943620d475134857902a2e549204f32bb90a8540cb5eebfcf383d928556f6d232aa7bf67a89a43422aca7a072529cf81805adb2960933dee07a77e77f281c15de870c7f549a13cb5e04c661a5100ec59f3376cfecaca091ccf191161a4041c1d01ceb920ca1a2817495ae521c7310c6c83aeadd2bf0425d6ad24aa991d485c74fb11137ba4fb7c2801ac7595e6eb72ce2e4e4a1518af161a1afdc581be31366730a6354ab31d2a6dce70d7636004e7b0cd79ba4fb512dfc2d741f4098674aac196dfa407a35b40523cf5c5b029171c4507fc73ed0cba2244a36792bfbb52132af6cdabf104a1ea658c1b329e80efb555f6eb4b5caf3cdad8dae02b0b99f88cd4e5239c923a75ff6c32ac02a859dd557ee24f5863c7a0354118141ad20f05e46f8d8dcfc9dc4533e15de2dd58ebf38456734dd104377171595fd31ad35e7b996965e572aa4228d5642fe16125b55abf206a8ef4ce0e92935d3ed8db95d27d3261ee21012bb878c895067b6f01e2056ce9d59d085f3e9ef94588f9c978d0414d0c931108fa26b73b8e08f77db0166226354773028a727fce98b81d462b879fc653203527eee11ece15e7943014b92db265b3f91f127d8f4cc6071d1cb60f64c5bd47a3e22437139847be5aa0b769b06005557154c8601bdb3f61d458369289a8516ca849efb7ad21af27148d4aed333111f6c69a89f8e0e24c6b14a8b443ea251923b03ab1b2f2103c082fe118b459098e02b7866adfee8340a1a4056547f8f05db65c91dba08ba66047b6fe82b1b02f511a0bcc565b91094bfe4abae805fdb5e90627473c3e98757ac54cc81f922d82bd95086e41ffedf2694274f68e013cd6fc1da4764f2e49d71e0b5fa1d6cdc70896e702ae9e76e89cbb12e7e1dd09c1788bb31d84729b4d3cf27a3db52f7cb87ce65122ed1d2fb95477fd6292057e8e94811aac133cd64012ff81e06afbe933ef7762a7be8d3025a82f1aa1cf22532ad4e47aaee7c027d722083680ead26a7e2c27e497a4d0b42d692bbd005bfa5147993176505af158e9e4eb2d1734f2c80ec6f34178045a81428e1fca5287bd31748f21956cd15e5cb804fdf3fbd60b83ce3dd922e4b21565c7257ea9e9bd178e30f7d22a48c034824eac053f3318ecc1293e549dcd1a4aa4b0018466cc18bebd0f87ca213bfa48695e86f9f9b5c4817f6374d56df4c852e0db5d6e84b3ec1e669e8759faf6d8c46aa355b8e8d51521fd1380a89013e30403b267b5ac54dc34f3bfdde4ac1dcf0d0f1e9025fa350c13e4ddcb661e77a4709f47724f87a95d849fe96c632e33547a13e21674c37973d92178305c6e859287ae9284880f9d2abd28a8d8dd6e6e345518f498a0605b622ac86bad445ebf21158ae44bde028e32fa8ef284caffd9f2cff441b9163f68600bea4d6b968d847dd31986c76ea61805d96fe114e037165f7d310054d9b1a70ce643aaad9edff68876f07322bd699628e84ccd3613e4b5838fe41bf2f81e5aafaf56bdf498cc8fcd1b8811d422b59e06e3b3c71493306d8ed6f5cc78a5d2113196ccbf5790f6ce94ee72d5848f9bf21969107b7c7178cf2a6b0f7f56d139f6a82285ec6c13257a688574280509574a5242fb6a9b7288811e666e1a139c677211de03052d1fd3154fe7271252734309a82ba2ce276a45a805e6cce1a721be0564185ff193765ec0139753817fad3a51b3cc8a08f6288fc58195508e8dacad0458e2438dcee4ce8d852ba6d86afbd93e2e07058be9930a1522396ea37ebf6d8d4285e1992859a9636767b77cb20f412adf7a6b20ab1ec753eee3bae2e2dcdcb95c5b7c5353b660f3990044b04d0a3b35279b6e1d80b65ffdf9d7eb86b457871bf85f314220cbe9dfad61eea48eadfd960b49419b8dc893883e4a31a15f3a35278ac47c61567606243d5caeb77d5bc3b01d6985308d186991535cb78d870ca3269282e8327147a840c154fb77195b23bc47e07d3d31ac43bcc2e457cabaadb01cf1714e59817952c05698d2e950f3ce7814c3c1f02f292ab18845f3bc878c4c495054223418d281d173d1346abd3c286b278d239b3544002feeba151f8bd5a52e86156a97f41359e223e425b2c54c0dac887cc45dad937914ac9475226d2e4be13e32481a6df65932e9ac46372a470858784a8301b2f4707d00efae0a644f7174ee245d8e57a1bc98289c226ef2e3501228346d0a4b51ab1c8e89a33dab2c5a52a0e4c2204a963598e1e28450adbc5aec9089f39adb6451a83195141075704b8eafb16fe64c9322f8b805b3a2bbc084c3a6755dd8f522180d1fb5acb0cabd555e8188b95325ff3c63e9feb99bacaf8a703b65364e75a930fee26d618a843671b087c5ef9239630daa834256100f1e4ebf957b97434b6c8f221ebfae1690e052ea25aeda692fa789b0ad02a4742a773505e5a61b897a320ddae443e562e9309f03aabd0fcf7c873f33c1c7df0743744be64298e9de2df2a7cd5c9daf62d4c1fb8d458cc7418ce5f521d9e1b9d71c9be069ab9951e5ebd75d874f9d77bc844af58ca527e6eb0079708843ce8c84846300e61663962cfe31ba6ef9efe9e448606f4fe0b81b9b550c9e2c56970f96ede343fdd1ca9f573e5dac3f9b1937c94ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"87c8a93c9e89efacbb43c81c7d6ccc4f"};

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>