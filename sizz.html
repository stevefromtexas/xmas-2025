<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Merry Christmas, Lil Sizzle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">

    <style>
        :root {
            --cream: #fbf3e6;
            --paper: #f7ecd8;
            --ink: #1f1b16;

            --evergreen: #123a2a;
            --evergreen-2: #0c2a1e;
            --cranberry: #8f1027;
            --gold: #c7a24b;

            --border: rgba(31, 27, 22, 0.18);
            --shadow: 0 28px 90px rgba(0, 0, 0, 0.25);
        }

        body {
            margin: 0;
            flex-direction: column;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;

            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            color: var(--ink);

            background:
                radial-gradient(1200px 900px at 18% 8%, rgba(199, 162, 75, 0.22), transparent 60%),
                radial-gradient(900px 700px at 88% 12%, rgba(143, 16, 39, 0.16), transparent 55%),
                radial-gradient(900px 700px at 50% 115%, rgba(18, 58, 42, 0.18), transparent 60%),
                linear-gradient(180deg, var(--evergreen-2), var(--evergreen));
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 900;
            letter-spacing: .02em;
            background: rgba(199, 162, 75, 0.18);
            border: 1px solid rgba(199, 162, 75, 0.35);
            color: rgba(31, 27, 22, 0.85);
        }

        h1 {
            margin: 12px 0 6px;
            letter-spacing: -0.02em;
            font-family: "Pacifico", cursive;
            font-weight: 400;
            font-style: normal;
        }

        p {
            margin: 0 0 14px;
            line-height: 1.5;
        }

        form.staticrypt-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        input.staticrypt-password {
            flex: 1;
            padding: 12px 12px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.65);
            border: 1px solid rgba(31, 27, 22, 0.20);
            color: var(--ink);
            outline: none;
        }

        input.staticrypt-password:focus {
            border-color: rgba(143, 16, 39, 0.55);
            box-shadow: 0 0 0 2px rgba(143, 16, 39, 0.10);
        }

        button.staticrypt-decrypt-button {
            padding: 12px 14px;
            border-radius: 14px;
            border: 0;
            cursor: pointer;
            font-weight: 950;
            color: var(--cream);
            background: linear-gradient(90deg, var(--cranberry), #b01b34);
            box-shadow: 0 16px 34px rgba(143, 16, 39, 0.20);
        }

        button.staticrypt-decrypt-button:hover {
            filter: brightness(1.04);
        }

        button.staticrypt-decrypt-button:active {
            filter: brightness(0.98);
        }

        .staticrypt-error {
            margin-top: 10px;
            font-size: 13px;
            color: rgba(143, 16, 39, 0.95);
            min-height: 1em;
        }

        /* Layout fix: your #staticrypt-form currently needs vertical layout */
        #staticrypt-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Keep password row looking like it used to */
        #staticrypt-form .staticrypt-password-row {
            display: flex;
            gap: 10px;
        }

        #staticrypt-password {
            flex: 1;
        }

        /* If you don't want to wrap the password/button, you can ignore the row helpers above.
   But this wrapper makes the checkbox not cram into the same row as the button. */

        /* Remember Me styling */
        .remember-wrap {
            display: none;
        }
    </style>
</head>

<body class="staticrypt-body">

    <h1 class="greeting text-amber-100 text-4xl sm:text-5xl mt-2 text-center">Merry Christmas, Lil Sizzle</h1>
    <p class="text-amber-100/90 text-sm sm:text-base mb-6 max-w-[42ch]">
        
    </p>

    <div class="card shadow-[inset_0_1px_0_rgba(255,255,255,0.35)]">
        <div tabindex="0" class="relative bg-black w-[300px] sm:w-[350px] group aspect-video
           flex items-center justify-center cursor-pointer select-none
           transition-all duration-700
           focus:outline-none focus-visible:ring-4 focus-visible:ring-amber-300/30">

            <!-- White inner panel -->
            <div class="absolute inset-0 bg-white flex flex-col items-center py-5 justify-start
             transition-all duration-300
             group-hover:duration-1000 group-active:duration-1000 group-focus-within:duration-1000
             group-hover:-translate-y-16 group-active:-translate-y-16 group-focus-within:-translate-y-16">

                <form id="staticrypt-form" action="#" method="post" class="w-full px-4 space-y-3 shadow-[inset_0_1px_0_rgba(255,255,255,0.35)]">
                    <div class="flex gap-2">
                        <input class="staticrypt-password flex-1 rounded-xl border border-neutral-300 px-3 py-2
                   focus:outline-none focus:ring-2 focus:ring-rose-300" id="staticrypt-password" type="password"
                            placeholder="Password" />

                        <button class="staticrypt-decrypt-button rounded-xl bg-rose-600 px-4 py-2
                   font-semibold text-white hover:bg-rose-700 active:bg-rose-800">
                            Open
                        </button>
                    </div>

                    <label id="staticrypt-remember-label" for="staticrypt-remember" class="staticrypt-remember hidden flex items-center gap-3
                 rounded-xl border border-neutral-200 bg-neutral-50/80 px-3 py-2
                 cursor-pointer select-none">

                        <span class="relative w-5 h-5">
                            <input id="staticrypt-remember" type="checkbox" name="remember"
                                class="peer absolute inset-0 opacity-0 cursor-pointer" />
                            <span class="absolute inset-0 rounded-md border border-neutral-400 bg-white
                     peer-checked:bg-rose-600 peer-checked:border-rose-700
                     transition-all"></span>
                            <span class="absolute inset-0 flex items-center justify-center
                     text-white text-sm opacity-0 peer-checked:opacity-100">
                                âœ“
                            </span>
                        </span>

                        <span class="text-sm font-medium text-neutral-700">
                            Remember me
                        </span>
                    </label>
                </form>
            </div>

            <!-- Wax seal -->
            <div aria-hidden="true"
                class="seal absolute z-40 w-10 aspect-square rounded-full bg-rose-600
            border-4 border-rose-900 text-[10px] font-semibold text-red-100
            flex items-center justify-center text-center pointer-events-none
            transition-all duration-1000
            group-hover:opacity-0 group-active:opacity-0 group-focus-within:opacity-0
            group-hover:scale-0 group-active:scale-0 group-focus-within:scale-0
            group-hover:rotate-180 group-active:rotate-180 group-focus-within:rotate-180
            [clip-path:polygon(50%_0%,_80%_10%,_100%_35%,_100%_70%,_80%_90%,_50%_100%,_20%_90%,_0%_70%,_0%_35%,_20%_10%)]">
                Merry<br />Christmas
            </div>

            <!-- Envelope flaps -->
            <div class="absolute inset-0 bg-amber-100 transition-all duration-1000
             [clip-path:polygon(50%_50%,_100%_0,_0_0)]
             group-hover:[clip-path:polygon(50%_0%,_100%_0,_0_0)]
             group-active:[clip-path:polygon(50%_0%,_100%_0,_0_0)]
             group-focus-within:[clip-path:polygon(50%_0%,_100%_0,_0_0)]">
            </div>

            <div class="absolute inset-0 bg-amber-200
                [clip-path:polygon(50%_50%,_0_0,_0_100%)]"></div>
            <div class="absolute inset-0 bg-amber-100
                [clip-path:polygon(50%_50%,_100%_0,_100%_100%)]"></div>
            <div class="absolute inset-0 bg-amber-200
                [clip-path:polygon(50%_50%,_100%_100%,_0_100%)]"></div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Bad password!",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f56e3e2996f91dda796e65e074cbd848f7ee798465982d6c2820410cf1566559b8e49f6c9db1fbaab81d2db91a7dd0fb6b2a415d3d197a6ff3f67c6047080f79d7123a5ba88d17aab5176b09b3b9649545e90c82fa9a5a7b3cd5b73666b200c3a4893af6ec9133e125c2e0a45f5d14e69ad0ddd2fcdb54c61614cbd99143f38855b12c17c439878f15fce579a2b1c6d674a45390de0cbf1beaee2e8542dbf5b59ef6a836a6c24c4ab9913c00ed7360d5f013cf39288f3de2e64843ddeef047cd03215431f813fa5fcaa8c7b3dd3b468c6e25d96ceffb577af3cf6a1f4fdb2c9cae44a65b9020c0537e4313723c3de3231636c55ff5de488f6e31e21bf9b995663134c7523ee8c50e69b9acdf7d93ed1414f47739b3183c77f03fc0df03c8d1cf06dd4543e608289961c25e17fd361072e62783a5a160dc9916d2b4ab95016e452015774ed2ecc8d285da3114d468768e1b2d40ea1724feb5b743ee233c13d30bf473a483696c4e90192fc7fd1039b11678de3553d64f777534ebe2ef6cf5b18707f7cc9059b8289045aa6e96eac24ba10e2c01ddee4805d59f1d4dcae578453a588481d7daae84ebee4df133ef8cf7f4a8ac6186d009af6f552f1bc7ac03bb97c3db017eb4d01aa113b9fe3a5bd3b29e4038923801382568a4d91028dd077b1de699779b28e2e96ce5633c2de657f39e8c96c77771411f94b0a826c5b4faaa466b9a2bb3d263e8601d7d6b6c9172785e21c016d58e84ae46977dafde64960e91409bc1f74b268f5db196bb427d535fc2cb9bb17e0f68efb9ac3278248f2320a093fd2ef9bb1e30a087bc9edda426b42547995607d3609ef577b00f3fa4c79a0f4b92eaf2ff247641091cda399d5c4263b152ee75ef80863192b0ebcc05397669b6478932ff9f3bf89b297e877338973bd39526df2e04335379e5d08e434506d4eb76e4db73d31c0a061cbe0207862be1fbb31c8c0c3de6daa5d78e2be56656ae737e36f9dd8d81e84711b38188b0d1d1206161ee9c6bbe45cf88e2d2fa166d84ca414183455414fd544edbf96951a691559792e5c82fbf3febba7a371923c11410d9bbf5879eac1e40d928a69e1704165dbe6194195f0a95df66e84c35472562c785788c232b9a7d089d77cccf3be5c02a4129466f4a7a058616f0707ccff87f391278d8c6fc7c4a11442d1db432f98b50e087a4807b076438107631b382b1b8b9334ef0ebfd70b290b35818d8f329ef126a9f987687953719d95b7c3c27ee0a9077b4122c09777801032972421a0f9e4d85d6a90593ae1354599e7e8f4f067d8d3f76c88781a0777374821667c5c2077f84e326e7183d966e096302b66322b6452f898d4c3c5556576e9bb6ba02f24b24cb8598915d39048866cd85e251b62bce37027e6c17f7943bad901be5c07a503838b101c256bd81c664e5f4284beab6f7d9fa5d27c3325635d9eea3073192f2b251c1198e0532b1c97cfda0df75ca0872b855ff754374b46f36bdee7676a283cd9e0639d667ea505f643391f8b5d45ffe328aba145e04afa7fe820034fe569d10a49037756131b23a2bb51864e1291aaa5a9fecd63eb40098e2b0e88721dd56042abccc4446abc1e7dfa31b5a0ea648f45957c26884b4759a4069d83221060d04089ba3440aacad195bf0e76efecf048ed6e293e4be35b32c6d862baead6d9f0b8957248d0993df6cd6b3dd019cbc5436955584f628514caeebe39994d5ca06a6fb54e4741150e92122012aca87f1b30dd2bc10a2ccc4e63f277d35be70e4027007fce323a13b9e64fe0747eed566b9c73f5beecb28773610c9864995b28b3ccc4037dcdb55616711608e1d5e65461b9f83504266e81f6a9a2dee82840a5f140489eeaf22dc73d5475554ba8342175d81e961c9505d0c846ef2577d7b94963f6613e8f9381df7ae757df191aa19024507a7a02600fe8dde3928d7f06789104e5796f2096e3a2ffbfd84ce92574694ffbd57466f508e487b0b3dca2686b61c46a87e01fc01bcbe33616b7b2d65dece1e60602c0805dcdc2182125bb4bead75da0577b3d56730f33cb3ab53fcc7a396514bb25fa057086a6d7d469687f0472b0aa99075daf5df5abdd7a89eb907b39b3cafeb1a7382674f29f6482e6fb72141da15d973aa879cd830015c3f69462b371e0c6625d3b8f36465ee99c2d9fa975b8b34f2ca7147c866e15725285e9df8647491a37be297f073fa19719f74223a94c71f99327164d1980cb9dd0889ee4b61b7edc6c10b326a8d14098fa942f7972427d555b30b171ff62b0f094ef216aed54b19af2e781c9435a9e46f90193f2f6fe487449a8bab36eb1475785592b489ce6583913ec0c35ef130510fc884eb57112bdb68c15c5d9e3b19805f7aba69a774fafe8ce27e04adaf9727f96b90bf5bcbcec6dd52623737ea4151d95264968a49182a0df1df1ea26e472d31168cdcc6aa131bb22873b4e38f957e7b24241ca9bc1df4622b7850d21471592d364c88667cd75117f18fad6e5a7ea2f407c42c0b7683cee907edb7146dc7a5d9759375f6ae01889acdf7106fe24a475f89cb9712676d7a99591b06eb7a8506ca3ea4707a3174f84c8bc9cf2b7f0d00d1278eca685750ffde7928d8ad6ea6103137d73ee9894efcfcc61ee1e3fbc2e8cbf5d42861e3d6c284544d35daa1dedfbb12e6385675f5777be64f88ab32dc80fe1a778fded2b8c2090723ec0e3181e33b8dd59946f9fd28e24ad0eb9bc51fac3ec194aee5b4086bc49f57d06437458af7f763eed4abeeeb3b6a208688406936fd146c3a66c1e7ec07039b6c0e34ece2d10f1ede7dc63ae14469a378c86e89aa0e9800434335efe0fcdf7efa84f54d9de20af15cf19655b3055e1fb8130d73b9c5e2fc4c9c7437c9f3be410e800b45111e5daf1cdf4045306bdef4044ecf1ac87c84dd2b4a6e79e19d672d7787842652c7f02bb3ccafe9aca11d2c526983a86a445a5d65556b75e08a1016f47f5dc240c0708a1457fddd55069d51d93528482e900684d7b70bc1f80b7dea14a9de66d5dc2ffe6f5387639a6de5195a06c39622387cb6765a2b1960a6af6fe9df88bed2102ec5e5140dea02cbadf2334773278376f44ce7e7072bed6d1aa93ed4cc75353e6cfa0eb6a32f2e54e545ef688537897ccc6b6a3ac5018970157c2b8110cd04e18526c2252a51dd208a12be28b2ae1f56fb41a0e6ce48f9f0212cdefcc56dcb7a4aafd5e68ef327830a1c90671525034a452a0e64d6e323014970c440f5cb687156c9ba398c6bdac14b3b442ed56506f909c71caa8e65f3d5bc26e53ecf2acf93cd7ce705f1195715ed072ce029c4593fe04c08658b404e5a540f03ffba138b9dcb2706626a83919fd49934cae9711f9bbff2c15ef53a23693fce3ebff7e2bc783066a2d4a97565bcaf4433e26ac6bb5f4c8a8209cbb486ce0f8dd25b1e30f173ede96fc91c37b2564cebc963826efb382776a72e661ecca2327fa9feb451fee019f02aba1ed0ed62ca7c172c721620a54e2cefecad46c8808eaf0911a7ea1d9a621bd82c8a474a1c05b6362c5a1236c4269ae3bc5da39eb13c2e4dc41efc16099d234b64260db2f745fdbcf830450e2aa4b9664bfd9ca129605435ee28ad256df2e272579f69cc159973b67deb44223899d0fcb9ca3003b2c361a292a7e48735c063ae8833a175f5c5aeebcc9787a2c4486e646a72f8ecbb4632e2c57ed304a1843483123c01a25534a403f614c0c71bb6c797c3c593fbc4701fe3c599ce3ce6132d39327182a649d2741d1bcec19981b20319187fd614fa646e47ed07813bda332d40526300efff255b6b6dd7b7d439288c03c6170a129221b5c1daedf6955d40a4225adb0938db12c04a19e01c2643397a21b613754eba37f8c3b6938bed148bcef9aecbf469147a6dc665d18ffb3a4988f3c4a8e453adf6caeb2e37f73c4a320e5ae2f66f643398f4a0bdf8e25ff0036a9ce9250251340b385957566e247d694383ea0ec4a3332fbf4b2dae7f583956a79bf93ec6c417f2ddd765bd777357007f021271bcfc81b8cfe397110a6b37b5132b414d42ec6df8240db78aa9d4c787b681fb3c55e5b8c1f6e61e9ad367f8719daaaed152b91bae1d60f70ff94e7303b94899b53dbee2eba2ecdb62d800a50d1417abdacb5a7cb248a71e1609c9d69c8a0e6af6cb48d7a1c25edac897cf589d2524c6835f381d801a8fc8738e73ab0729c9e2f88e11892da8903f8a4e215c19b41d097f37948f3f05214c082af4a4562c89c5e31f6dd75e7be0207bd39d7042c9be6bcecaf2f4dd19c50463d0c015ba52bc708e67769fbc908e793db997e3df1adedcb96645d615e5aabacad8f18de9dd60f149ae3bb47434935bfde8207b00b62f9a74ae32ef24d3c74ae9a64898c9140b2338382322d25d47c3bed23ef35d08e5fe6c69b6e441a337835beb0cec3d99789e693dec26b1b496b61e0cd88dc0c516bbe813bc9715256c1e3d829be257454188ed22d25c310cf9ed935e7cced989c00643af8fd385b3ff0a08209cd70e857c9668957e443467e7b353a9e7bb78da9386c642d90bea765316e8f254d40af76eb6ce7526ec0e6dd7a9e3f9105196afc1482fe4e95a2aa190b574615a9809da5bd56e38f1b837c7c829e74721861af05cb588b19de7ca06bcfb5c56ed407e00f74463117f8a29da6ee93c9ad3ba490de52938217cefe9ec08c5fd3d9c43eb94b59d46cc9f703ed1f6ae5b2680bc2469235134572a8afb838423e8c82b7535dd9d635e19e792c8d33223eb6dc953a771ec8de81ae60fb69a383a598a270c2b6ae46402c337c3ccebf29447ed526f9cc86a5f479e68eca392c48ce2ee2d80d3f9217bfb75ff44993bfcada8e052a6e240fa1188ba6cbefe62cad393719563b14d6e3edb03ff1a44fda5ad0af691a11f397a45650773cc41e69c5758c73cb9e6f2d57068b514accc1bc839147b18279b567b4a50ccdd59441e5d2fea9be7848ead3370ffc428e1f251da55649e13a0cabee9c342233f84e15be5512cab2422ffdcad9b5e93f514aed0db2982b4b8e9a5bcc89af7f04647b440e45f6e809c9565ca8f9986c85779d275f0ce7c4d466dba5b35fb0650499d1196a088e0c23b914743c1be5cacbaa1e9f52e808fa4be609f11d778fd299beb22809f80ed4a69f062c710dfdf7dc80bea2305f6aed31910d5fc0157f7ff177220882f1fa0c1d4eedd610bd7cf4ac21e2dd470975a4604f41d64e1cdf9e83aa3bd2521edd8265d512d47712258549dfd13d85042a46aebedc7d565f90cc8ad9e4565e7270c330f39b3d19b380ad7ad1c32d4b24667b68d1c9f628f18743fce996cb2ef8ab40750e8c695da3cfbe3613d4e44d61597f52588f72ab4a6a346fd14b41e87853116e6638e0dd2f5d90e5c5ccd6e61139caa4ade66b0fb5fa939212f1a97da651fd2ba67b70de5cbd527084ce69f5de4fd4e403164dd4ddadcbd718b6b42a3e39186ede6fcbfb4117ecdc11c5ed31ab815eb4617d4adebfe68410408bb223eb6e4d32feefe6ea236b65f2c5173b361878a22a26a5a39bd5278de8055ac4239a87bb2ed8e7bb369e82ba390395afae12b17ae2469a4e259d50c92155c85c6f313859fd55d60a9cfb3370951bac35d64f9dff91c1da96b508a2b89dab2d03e8cde763a3a1096718a2e71b82cce5cdc71bad2d553d054c195c0556e6b4521c18eb12b148ba559fc0d09353fbaba6b84e11078d538b0bf811d303456783bac4b8c8836177bbe6766473b2e33d4ab5e81c2ba1ecd5ed69ccaca40ecf7056748d43fdfeab9312a3899bf8ac7ea2a8f2e4fa44aa4b370e510edd452b556af05dd4f800d4741000c3f68b58f727b326673bbc8e5665e869e8f8cef464776e1dd9529b31e6856a635c8e0edfb928a75e50faafd5e20b6e1fa9f6595ef84c912b612cacc992d8a15be513ee70427238d7c718fe78353da18f8694775d347c4ee35f022ac9d5f093a30f9cd84b485c3e8a39f543d6f73f4fa15ff87ca1e4f6c21e6d1ef25d90a17a9a4d4aa706f4f4f145f021dee25f6b9ee54569eeb9c965ecd09b32be81f99cde78ca71d56880a6c2d47a8863f73432ec53fe97cfe456cc8d77c6d07d5ccf726266612dff4d401332e4bab9ad36135043f7056e4a75d8bef6da6272f6a8a155b22d2fce9decc14779dc692760b8bbfad99b8f2861cd9df095d779a7750cfe7ebaccbbff9b52f1d1cd48949a4e313324a12d816b562373440903e4fc7ef8e7a1751a3c4fb35efecccc33199a2fb874eacf02fc4ee2444c408a8d6437be9066b45441051a4a58bab917d19e0a6e195cf3d980ca140056ec6c8e2b3991c478981b977f4e2105cd28542d3e5b3e4510c3f5d13585e15e660aeb5aeddb4e3b9fb80608bb283af3ceccbb14260393daab4d96812b3c16f210b6649efb0e677ee4151ada658e0571c6d404fa49302ea990d9f4bd6ebf44287b54c136960828f7230b8bdc4754bede23932a44b2be5f769fb441cdf9b4fba9acd46483c176fa0bf32834bcb402a5d90ec533b78980e4fa4e7d5d4d3c4989bf46b7f0c457bef9d7f3d2b4867ee57d94fcb545559c3ec2ae939c4415b0d3a9386157348b21929dc8f19d70710f5402c6e403c2d8c0f6c0c71084d5fb9820e14cdee0590ca62920d5eb25edab5e729b6f6e1d1664fbca1859055a0c0baea285966988ee311a32527f59635da4d9e6ba4b8ecd2083683637a283603e0ed9c4bdc6d9bb7f61d20818e873003b42f568faf65d6b7129c4f775f5e7dcca0175b678ea76cbf3a9a335d47ecb7251b29d48d5accd57fb92a210a3e5c210b8116251ed55c067e9130ff7845afa079965b228e9873382bb8cbdab88bc724511ca2f2011cf6919107a19df4683cecaaa77bf718e31a1639fe47245d20df3b7f633771532fb08cf039917055edd164204b48fe38aae1dc4a93903c5b7eb1901c5e79f8c3bcbe4462fb22266c8052fb53bf19844a02c8bc6d797967abde5e4ba69ebb0011272a875c2b91c5d0d0da29ee04888da5d53933c7f26028aa384e8fe0d44a66423cde6e739f1c962f8fdb9cfbb42e866aab2214bc3704080b555fc97947bb81da4eb866d68ca8a6f8b193d5a30898f466b239394e4306ed6e38aeddae73bdba5b705dde22badc997172e6ea08eaf0d942e031f40c7b741e35d86ff782fbf919fe50ad55d947c5afffdd21caf52a838d47a9a664ceb17dd07cb6039d91113425103339f52ce126458594d7efa5a29cf2eae66bc0c6d398fd05276becff5d864cb714e38c268b2cc85790744f5b9dc4aaf94d7281cdcecbbb85a248d6fbfdd069ba0df16047e58955b0b0ea3e39b7311169284301fcb3b848f5728d417630f47fe9874dfcf04c4d68ad43ad7df5c8ea8d1c36e7e640735c6d5fcf86191cff6e75a02afdb46492f56a69d118d070ce39bdba4ff5710673d4ec768547bb9a40ee9eefe6406814a0e8efc4c32770a3a450b8bbdcaa4b3e255c6fb069b3c19611067af7687a002364f5244959a5babe2bf4e7d61c3560226fb39e59709417f19c06d1c0a158b69d4ebd95852e6aac6a32c71fc4a08d884c84e05dfda3788504df86c9aa0951f9c890eb1a986a4d93af35e944cec9c3a5f81807794aefc4a77c9df1cd2942c9f63544cc586cc1a6069abf72740c6f081172cdb06df5547693e6a513c8675ca8ede0ba8c283591eb2f5a99cbd0d85fccf53757f6eda47666275ba8c771188be71b54ac27e26655185e08027bbb71f7edfb3f02229399bc417e870fa7650f4108a6c7f5aff0cc0ba750f3cdcd7e7af80e277be99d7586ba03a7aee32a2cb728b7d761f470476c677a55c99573d2f72d9c9d31ff88cbc21d26728e8a6f9ed0ec99e22dbb1a162fd2470fdffe599f0c1bff20c7129d1f854754d5ac44ecb9541d2036bdeb75ff17ece4a369229ba13a4d6e33475fd528620ba61ce93d6e90683b6d07ce4dab6152e5aa3efb1e4dce17c24c77009cc945b5c5e47b4fd471481146ce9cedcf16101480b5fc5a48d75c7908b71502c7877170be65185f83e3907f0d031c009946af5e6ce8dc5b72d5d0f11308037ed13a5db69883412b45b7cc59d6a859f575a29badbd99266b8ea3cf38e892b6fdcf0b4bc5b87e1566b8dc47a4ba94df4adebd182d8ccf2c742f84b43d20473664f4d1396050d8f7b7c4051e81414c39d9091fca0da5cb2879cc4ff2687bb2dca4492028837bd0f0c2f6e2c7001a07b4ffbc8d700bbb38fa0e88de48e4536d301790068975173713c06e73ac3fa551e8ca5ce5112e58227dd7234ab769b2cfd98a7cb0c29708bd5f72adf15353dc7d86b9ef7c56e2414631e0107a2e12a0ef333fc41cce3a6cdcfbdd6c69bf0da6d3b7638353bffd96eb32739bcc6cab199a5e003bc8a0c53e4a10cb7276e81e60cff74899dcb2a93a6cf0368987159ae15d1128e66a5b30e06c44c79a61b0dfd7f556f7630d27aff9ea808a841489498b0376f5d8bb2fca16f371251fd11dea14d9b420e2c1e75bd4bf027636a144320a455ddbc1b1d973a994380856914da97b3dc359e63b64b48ffbb16cd86ad4dffe9079333744a9048835711c34c7afd3c84f8faf162750210aaf025072a3f2a7b86ec5b9b52045b6f6cfa73f36fcdb9af245b457d4172dcd849ea4cc0361acda3b6968ad04822e0577211a29e4e37f8ccd1a4b76f3b34c24d2efde8afbad6357f55e840d1932bf1625e59de0e49903d22d38fabc849a2db91bee0f16d6dcf28beca44816913782452aa8d70f13754052a9818cd31679b37839bf8efcfccac298bd394b053743302a36ef65522ee9c4aaf8899d1da6aea7f5e3630e9807f958c547cebce28e25535bf17f43cf7b104b4697452125c89a5aa9d3bdfefb26d4756bb9cdb38fb02672b77fb42a40b7bf0917db9ea3b345b95f6d4d5d29a5969cded091a77db65d821053e9abf83896538ee3a4ada80b98b9250d1c5fb3d3c9e178e63e2c5064d6e99feee7b9d0bc053677e8e7095383890868938e82129fbd3e049272d39b42b3209b7e214d957b8a3adb90585a59c355eead9a3304fee9c5d5c3cc9dd250c3091b9cee2e1b32e17c2b497dbbe6b297c50370653be204b7ea6575b86ff1fc1a879653ea8d2d91d86a8ca8bc69d7919c4fff9c4606ba9f181277df75565bc7ddb1c40b5a0dc881066ebc4ba52e064beaa55faea11f0127ff0ad7a720ba07d02f37d12d66ddfde31cf622c1be5fbadfc57f11a842d253ba0ea412ee9c01472bfb75f5648e38c94ba3aaec81736585daa04880d91facf38163979836d2748685225d75f6816de985178fbcc3f30a02bc7ce2bae59a1ad98b3064bd61815e4ea2ec641167863e7cdc1e0971e02ab8b4c54bf756b1f04fa44f2e1f3d3769d5e8919f0426a4ae8dd4fb44735fb303466582f7847bf7d6751386b82fc10ce521b16c09cda9674d9b017841c853de512ac3ca00e9a9c19fcd113bb89a6549316ed2206da1e3c8c15e0e2a4cbe9e147f60577547d216652f1973baa4c6d5c00771852c3459f5fda11b5722679fb1ab2cc219a1ef53dcd82f9c20ad15304a2fc0d34e55ce119160f7ccd4aa67cdbe7aa8526a893f7be876910497eecc3e5f09aad940da792d1fe3f51f03d4998d41cdec2ca58cbb8528a8566a67af532a9a33e3e88ebf1d376680ccee030070160e59774096240e187e21274161267eb9efb063b631025b340a6a70833eb7901f3ff5d67911a541a77961a00992040c77de2015e3a47c5824755ebcb4473cbfd48035379c9c1ea6ca94e87c6a2e2ac9a2c04ceb0795b362b77a42471cae35c395c25cbcc474cd422b13b271c1b614cbeb943c7b89ae576c899186e35eb0722e8b288b34dbcf1ffb6156458176efaa01bc2476cb04c2094276fda8d447639e19ec9d62a33477ed58afc2fa1a4ae39b635929b5bfb8c6c8544dc2e1f421f777ffaebbaf3bd6d50756db64f00143fc3fca7d1fc8f75c9747a04fb223905fecdbf8b2aa2a68ddb1d5160e4752c20967192a582acb00042df7052be32c0ea2d8cee3e4ce6336ba0dcca3fcbff1b64c832390d8d83d4c62b3daabfaf7f27223747d8f9421308ab9a2c2ce79e2e78a2ae0ad94317c85d9ceb22c2ad7b421df9d83a24662a628c2a16267333bebba505ac8a5a202c49e98ba51bc93a1f2205530e196e8b96d11995f1d752b5c7543a8d13c8362a35a51b1c52be70fe9124d9ecacfc71c2030c163f6e034f56d94c0bc2880d7e7d235e43748bf0a3f0fe36d103f5f53350004e596700947d0f842056789aac4c402e864a95665e9a4e4d040fa0c644f8ee3e8777c786cc29c0d676c68acc68a0a584cf39395b32c931b4e4b0a6eca11ed8b0a9e17d3ec6bfdd0eb1f3ffc7f59a419cfe2d819b4bdd37d91d5867bb1227ce0032843742b55740c696cee95e8691f400ac2d9fe08e286d4f30dc8109a8ee424e844e086f966974f078a67ddf81077bb9db5c844fd298b80b6ef8a3431524c0c3cde55687a54e378e7bdddff1c534b407c53af9b6a46d1e1401527b2d877f905d79d8442ca5e5a610b8b5a60bce2bbd4fe29074498d561957564826b42d0ff4a2d7c0c54c6c1ac98956e016c9d7b1bdedfb80e5cf0a948cdf9200342f26e81c1145c1b67a544e063dce955834c45d3a2f98343b6fd0bdb342eb08e480f4efbcdab9b0956c1040818a8803eb3a9fca9ce0c31efad5b901bf21133b74a71e60e6d39d9ddfbc3000f4d547d3d7758977fed60200f9c3961a3c62c9df77822d7929834c99c102884f430075bf43584cb5a37e1e6ade0cb8d8cd62c6c47e5d04747d58db63438f575b879fc04721624d0c91435b75dd33b55bb0c9484d7ce4d79d66384cc7afdeb956fa7c6a35e644136ce1d4a6e48b084466133c849289ea88d96c114ab2369dadfb0103b7a3e11608c99c92aba8a8ed2ce9b5a2f5fc640f3291cdffd03002492989f2229a7823cea17eaa9b6a91e03c604f05d2cf1bd13deada0ebab75e2278cd9d32b14befe3460078bf5e8633183ded62ed5f95530c3a9674f3ea5c951dbca8be3312d4338897bc934761802140629c82f12033faf15f2b2492929ed91474ebbf2716bbf3e43c78c176bcc28096cb73e13425dc07217f0ea4605f17549ff5e6a3aa1502e9c8ac8940243dc827134ce2c03bcece06bf42d8407914419102c8716873a0c991d68a0b071707410dc256001c05efd934bcfdbfe54ccdda4a3eb4366ccefcfd65a0937d51fd41ffc14c997d50ed86aaf35dc52598954dcd6945885da7b65583315ff155b657a494b6332e9fc32fbf5904355be3efbd1fa0524d8be405ff5af6e6576b3b2e395c84b6bf109c6569fabf73a84f8dca53bb6ac3c4a2efd5c0bfb99e4894e9613a8578a86906afed4bd7f90bdf866fa9612c2e1ead0c1f8f297640b7772e2859df107dc92ca662f5a54670e4d282f874ad8a875d79ba5bf106b402e90b7e66e41fbbc17ac40fa6efcb46ce0a9b6bd4c8e2bdf5c34f5cffb2e4243fcd84402468284d034ea22f244c98aaa0e2135f4599ebe24b3beeb70c99862aed3a9d35c0d3fea9aa0306ec3ae94bc72b842d75fc776225f882bf15b50d703d5727ad9a69ac1b87b61a3eb5d216c3ef8e9d141826e81d81ca1ddb32706fca9947f6458628d3a82c7a1da839b6e74acc302a03b04528a55abaf98498b3df772fceccdae851fb610bc93c281b829deecc3835a5304468b37f0e0114848c471b16e282c5783318d6f52ad8dab599ab45c3cae3e066f64d90890f4f9c20f7bf67e59892e8b38d3f9a784d2ad722d6593b77d455d104573b2f06a2480d276553918c9de0e5ee15615c4a928c0746f09c74ecfebe647f801f3b94a3fc3cf83b367fdc248c746503ec559996ee68eecde502c1b495242300969685b40569e35cf46ae4db77c1c395150cbbd9c304469c27585d4deb43aa6a09f9af3a5129ea0c5e895155bdb228bbb6f0e2b0e2c0c0cc09d3d1862a05977fd452f85047887344de7795aeb220243f77b612d4573bf5fcc95ae34311c942fc10190a233bdac55e5aff0e21002ba74387454f21b7eaea4eeb1f8a3a6606375709d1f61c63dab53294052a8a5d6719364197d2f932c5c90f1dbb2cb0b50e74abb2f7f3793ee35771dbae89a1994d015a1e130c80f67e4baec3e98efd431096c04dd9b55df70dc898367381b50f508a55910f3e0decf401f9732646dcc956b8b92fa3aa51bc390c7a72874f9793fca541e52b564ab478d60166fe5a6727d7f4232abeaf31a406d08e9dff36c80ec61595eeaae85fe4162469fd64e521a39f625433f8132d6fbd542b377c7ee22ea8d068ba74242d569d5c0258b26c3da973cfcb5ae23bd0aca81a1d0f11d07931e98b7cc09ca9cdbbda42c1450526fe4b7d87e36fa6aaa113a0c09fcebe4844bb27acd5dd2bc1749258bbcdc81a2c7fd5ea984ed49fb284d8700eb7a8017f942f694f8117826b52d738a08934d19e07e4a5e34c271f876ad08a78495737a86132134976df459465efeb4902df088cf38f6d10e68864c37f3f24ef0b4c65d225e9926a0d0ab710e1970e20cda1971aa8bc68e29ddbf864e30178c3b0fd606212cdcae5a8794b644de5ae0797380ff2bc9d36ac97efa16ef3d25269b7b33fff6c892d437c732ae38261a162e27aaba796216a70a066b73644593176cf33c7fcfd2e01318e577eccbbafd9dd8a320ac2aa68b4ea220916289d36dbeebbaaca2e057da655199482d8d3d373b97ef8913bf44603d93a70299b0c2b7c09620c693dc1985ec3acff4350acdf91fe9632ae7aeab63b699fbc2ae45ad16c44a47acd2cc90790a76087ea3a350db7bcaddca2b7d45bdb90416fdced7eff5d902bf10968fa3c1d24107779d44529e2cf6a375f9c3e53c0c45bdb25edf3a5293949f515e896c7b2ee749b8cc608d56eed388aa83bea450a6b0531597c026f6de15fa55b91a80b3d222dcf0a9492c780094d4ed9766c9c6845c04fcc014c6bdd0b7b0491c4472018904164795a6b8dc101c4c4fd593a4eea807cfbb04128c1bfdf09f4572d607d3f0edebb35327244545d3c7bf50e1ff0b2f2dc82a7b02391dc627ffb4a8556380efb9691734593f0318c25f6ffbb468b01cc62390414878272afeb133a9aeafcf8c953b781dcf228449fe5c717b5ad183dd57baa3af48539df9fb34aa3f03b073e652db0561fe480d872ddaec688d28059c43164d5a5d5920d1b16d78dba67cacf25a170b1dd06eace3dfb335de2123b6a6abb0d7416a1c95e4a7629044ff050b277a0671f0ab66954fa7e541e9ef4bb16ab704552e1c1c47aca41f96915f49a6dd468d0cdb818fa274070689c8a621ca640f19ce8672673188a437940cc00196a723509d68dd39ac397a2c101e9aa69b8c571a416456b9b41bfd017dfa274f26985760a44fb6caa63c00c30c67c2c362df10171fe0a4d2df7e36706b26181dbdf04db6ac27d811a09950139c77ae709618a54142123ffb7ea1a347fab14d88be32c5ec6d0c9c16f584c3ec036f7ea85048e6b10d5a2ac180400b9a01fa2ec569ce5059c7ba846265ea9cdf1edfc26b22fba9ee033762a59909e2026a94e0c194fa2df77b72a487bce34fde8d8db35c99e87db7e980e6142fc61a05f414aa4f1d2d1bb1edc7b0f157c06695a38c08b8b4b0f7f0b86dc4b63aa2b28a6490b693df6b6e0bf967e4b6aa6868015dba4dd95e7c3867c05865952cccf2582aae78538fba823480a09b68608f7e36f4a881aabbdb8c4d7dc7898f4801efec30e5573b2f99aeaeba1195d4f8d8e82ef2c0ab3d334d177677e4595c344a13d236acb244cc95994929521c6349426e9464c4bc5ac702848333f0c730824a369b8c0e059522703251ae824ae234f6f943b555119205e5a877ea0fe9ad4a1effe26358cfe0b5f4bbf2e50441caa18d4984308562fbcc4971a88d1daac1c78f40533576f544a421becd0b85f7e5b45edb38adb7557e080fbe0ca929b4d90189b202c7ff4ab9bb5978c84a6b6fc04e18cd9e5a7119eaed46e6f09f0e8eb47689addd4e89abe64de5d2160bca7791eed3e890668314d26ba3bca08bc55abee3891942b32691bb7c27c1225de325b6b2b1ac0196abd7d4f11450b243a29e4b0cab19b638331f30ac4b93427e7ea467b7fd112951559ee8149fb3fca6dca5f796f9c367bd6b569275809b76699874daa38fd81cfeb9f6f1fbc7b02d49387939d7fb037622b6a8c19d367d7195fee92687f308dfc01d4faf4920ca6ebc6ae35837b04dbfbb73b8bae22a23d756f13c07ef9ed0451f0a992356cba3565159526968fefa56b67e108213aca4d94bb2b7e346f144c238c105735bd2c2fd4c55d924fb447df63a174b6fe45ec76875ce7c1dfdefed8b3f5bf668f0784aeed6bb18d4779b217d3ac04d4422d3dc3b7341d9244701c867571d2fcb26f79134dc8880d66c0f49470b4afa354603bb87bc095f360ef53a85c904544fc15a4803f723ae0024d29b01b0f8c1a88dfe064fd5f0189d7f1fccd42684007853bf4a9a252e4f4c6ab4ae03c626ba99ca7859fcaecfc6e56fdd425c2c19f6d7c5b6f732a70d5911bacd506bbac70321e95ff68b57d9f8cf5b1c5e55286275c7dab0f9dddf376cc9c770caf71fbc4dd40219e14045e0693836d82da7e8f945a1cf260f2f99e0d03a94e9281bcccce4cbfc245b382a20a2576066c5675472ddd687db682c1ae1af1dfcc2560276029fec438a49af3ef35c1638ec34afc64819ea70e667587146b5ed02e985213c242c6b8790eb524a7af822c5801bdbe44d693999f80b171d6f2b1d6162d00d2b9d874bbbb26780e4bbe09444b8ebbed1f5a00e3db0a8d02de559032e7cca28db3d0a24539569f522acad1aa0bc178569e71756b275ced021f0c4aadb21ce99a7a9813231bdffffd084450e0cc913dcb65b00724d8d0cb6a20edc2e55458e7324facda0de48836b8103afc0b520925a0eee8869b14509dec64b73564ccb3130f1d069412f010a8dc4f14badcf3a8dbe4134223dc586d83c79a55c14331e213e8db40d8f3a10f31062a1967afaefcad1d2c17e622b49f948cc596d510aea8184cb233321b50966fd546c8f25548e0d2378e63f34e81b35c17bc032c8a095e04ec3238ba83007723c95bbd98919de92cc82f9786f58c5cdbcb184f47e8e1d46fbef9cf531fc6d228508964e7897a400a05a5f252385348d63764594dd88fec6a988b68bba8896a50b9768a88b1042bb4998f64eda4e018cb5d8701b32d8469317870c5091eae9704640cb9d91f6ff81c689d82fe3aea57555837dadc9a0d4dbb3b1bcb53d255d864c56781a9a68cbc6d68aa592e6e6fe40e38e14fffa03de09d2eacd5e8cccf05a3480e37f1fdac43ec19dccd97e638893dd641f4ba54f851a460287151b67c481dc19ddc0ea69e0fd50a643c71a2101314a2fea84e3d1c01eaefeeed5f816060371fb2c3a6d806aa452d13f5fa323f88850cf2f7c7606b3556425418a23c44b1b03c8cb6db15544f0518d74bcbe4e1c5e1a9f0dea74d19dfe740c9a81f18eb3cdb67db858275dda4e00fef6e8ce1f2140255a900774fa56b37f8fdbb92ea5e75cb4c6e7baf2506a952e82a1d466e8ec027779a7136b86b8214d8f9052074063eb7adf34a542e86e369a5fcf06fd55862e7a4c1a1e2894332212e41712b4200ee582d20d183ee7047b034995a05c8b1dd1c840ce4173cbf54f2dad84a9dd88cc31e768020798e3b420a2acc09e062fc09b92a2370dc7db2e98f36bedeb7c9b6262ed8a8185831a953609d6e7fe0959f5a786331ceeb31ad728eece4528ff284ebab61c810023eabe94d0ee813a5fc840159f77afaca38efe37f2db5d42e56ee14e4f146d5361e872b5690b26c19c5c078e3661e23e087666e1a4bfcab52cf3b7a3fc67d6b7624a4271110c3ddc21a56ce489658597678cfe07bf62a5b359fee1a76e7fdfb149e1da0bc4c3811291a924663593b32e3faacfaf9e56ced43b77d8697e7b4a17e64fef3ee717f10d8087fe008a7a162dae574e739b3fb85ea81f70ded9cecd5d4bc22a937ccf01c5749f880b56a519b7204b2ce0264ef2c671cdf9b94edbc154cf24a10bb18d559075d7a7a178d54521fde874b5fba75ab6e777147dfac89e34c787a9d79679bebf5b7bd6fca6813f663b3a68b9b8a13876ac8ff00049bc6041b7a819080810b9a4150f13bafd114fac4dda3a481dbbb41ebcca912e557b1e5c0684e06e6d1e03836ad76047b492fe170a63d0b42f1e6329cab127b0771db61e7c033447e9064c14f5ac52d7f5cb23a21c3eaace0d0bedffc1fdee902be787e2cca7aaeeb8a0e745bed1d87a4a647268304dacfae01c18957ef6501361acbfc43056aa934f9e54c831d9448f1fff98c19d7ba730012e8a63732f984cb9d2fcafe999bbca3b664c71f0e4640b3f4f74a0c5aba0149300c2f4ee08add1ebe4fb6851ed42f3de37cc58139b45fd279f2e91cb231429b178a57f01b02dbb47e3a6f36336183dd3192d4fb690f8a5d6fa7ab1c56d65936fd1791237da9bd8972e0bba9c4865c1e4ba8771bc398fac03ac1fc1b68e712c6418691f5ea10b5775913c8ca37903af19d116f9885561dae59342e66d84c83de04b01886b75a47664d540e477ef47c057fa04d897195742265b9dc3f43773f4635b228e10e7322a0ba0b31a635dd80b0f1b67142d34a32dcffe1638866771d5ff977336181595eb0ea4d62a4451509a99f54cd7ed54e7d7378676924b53c2741ab312a9477887bd5c848b2e830f82ce38a46c9b0c7cf073eb25be2cae968606ed8ab57a3f1999e23b6d4f9f72a1fc43b4a3ecb3ac28a9fb07b18ddbd97c22f5b87cccf2cb379b985fb88388e0ca850c7df553df342076ac445e2c46e881828fb8ebe542f35bf1158a7c95c44c2aae51d4653a4bc1cf449a008f6b4962e4e4cbb8c1d50c5e2e94b374eca28a498895fc844c78ffd971aa420931cbe40f03041cfd03e14496f27e68dcffac965097f27ea81fb11b31a1703b847afffde211154da07bfbd6af69e2281135ad7a34753a17ec446d4390bfb940d28d8db58f09843e3ec1ce1a4d5ab038a0c20001fb24e22d2e5e68c68773346d5aee39a38a4981551a99e4e9742b571e6ece2350d611d685a147e841c6f6af0d17a392b36c78215f937ad152a4fd3dc637d70685632e65254ebffc6391c8d5e4f6cc152b1b8d0b5da1035fbf5ef36b6f987e8a33342899036ee6bd50e9b7a4beba787e528eb0d67f16a3311d29b25dad03fff6b6a311b376d0a182104ad6e465e644f1e5cf8db038eb42cd01ab88480e982cc0333ade97cc70a00479180a1a3d0b795e8b33380c1f0ecc4a4bacf2cc030418ae0ac53e81b2d423c5297dde7975a0e6736c5c27c4fe7416d39c5210b53b4f230d472d80298258f216ba0a8aa57c6c70b165916e6163fee63a453b88890e55b96c9c099e046ba47098b20d811dbd32a93c71c0c1b3171bbd3c18caa8b69dcd7da890fdd76f61f6a0a6c6bd25eb60ae44f0ef9862371d44c3f609b756f1c44a55c19a95bce762753e0381e9aa9b4b110188abd7ae851c02fa023f561ec7ccf0933ef3c636f57c049e406f8949c7c8c04048ccb657968d1873227f6e6e4ab960ff2d69c53951236e1f316e6556616fa58bf0811a88ba56b038784d6c09a5dbcedcb4b723f043da3dd325af45c3fe54342067aa57234ab23b1ebef00d8e2cf21b79678fe7a4d33bca1cbf1c76aa5efb9929db05eeb441e51e0a2213beae22087d437da4d307beca280ad2a35c366397b9e2247b6b97d1824a35361ef0abd097d075237155906dac656712889a5f2ffa9d606793ac927f731e07aea7c474542e1ad947d515613bd730bd904317540b7286941293293d32b35af995ac8f2113991ea85c5f59aaf726ccbe653056623ce79247d3a2784a30b29869ca51efb98abe551244bb37677e4b0a165f0b292c3b21e6291a1badcd5058ab9918a72ab0b79ad00e4a12fcbc8a03e33980a628732dadb58fd5b9066e4ce7308d9ba4205f89b9620d496afd8107a58d312b982853adf93d1ed53d3cd7123b07a60cf07ac1a64eb6ea0a68abc375aeefb1aeeb22fed1739a65d6c3d0898ffb2ef99a5d61255a062cc27f713c869708f630331980ef20d3e4cd380ed35d60556816d4c15303d8e57c14f51d4b161dc3758b912d96f18abfaeb40ea7815b79a8570408a31a770de25511c1c5bc0c1d5942f31874b80c982fea7d25e4f4e2ac03744f477c7f7f706037c4fac6a93b3ec6d4e9a5c2e842ac10638c67967b6e3774a180e4f86a7f35fb236eec3cadb8658646fdb6919521d8f3b45ba46811cad7730c8c0ff0ef93e5cf83e3ee7477ad2dc5978a8ecf3438eb829fd8942cd4b1daf7238398ccf7f557c9b3dc379ae11b210b7f74e4e56f43c4f21f8e921f22c7c4469a112e306b14c1e665623bfacb6aa5e6e7c2aaaad9a1ecfe31a762e3db7e758048fec67b3cb296273a1b90a8ca7d4f5b17fbebea24f80706258bbdfc890da830ea43fe3423de1d067943dc150e558d00303c8128397f93125fcfacde00238083c380208ca8a24198d580ba8003671be6b802855ded77d1cbfb90f14710132d04adaf4d9fc19580a336a78079d83df190e2a790863ee3c4c4c5eb98a4b59b03a1408bdacc44bc56e06b27750c57fb6e67aecfd9ccfbd04b56daa3d62aa257836c76d8ce7423e0f701e8e2d8fe00b4e0896d1f7447bf01914597b0532b20b66450dc08c141677d03611f3068e457a7a8c2ad514b879ce15a00b22a078bca97507104e1d73bae53334d2fffb289f07b16c27cd56f098a5ee2850ceb15b4db0b4468560e4c693e1f15f2c80f7dca7791d5e15d645a5af1e095945a003d815722c2e246849df253eeff8bc52a6542ad3779b895f0381332021d70d037209de8ca5e694339c0612b3b4b7410a8eb9806d2192e18f744553841cbef4a0d08ea990044320d2eb42ae54addfa6b0b9d29baa2d80057449ca04474c3340ee9cea3f01ddd0d6aff5b30c65833a61a23f83d75ab41e8498037d802bbd80c6118a94c74d49351951ac5414b867a9129498820b0f7ce2b4cfabd82d0c040ac14752864dfe4fd9ecd8562570749ca2ad5ea98176a32e9c9d60fcd282f91afbb42d3d3f86368c6facdabd7d1439808d63bfdfd49f6206ea4b8db49dd8657ae1f4ce301bf3a0b452f8437523b06ddfa3186ed92aad1e161ad3b364a4683b541796af2e8e72f7c48fddb27d0ebd950b20c60b6da80026c43d7a5fefe2deb1a01915972f4a6435f8b66647f1c26f6095f36f30a41581506daa6c4639a4b36266be4be4fa9d600c49044a740af","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"87c8a93c9e89efacbb43c81c7d6ccc4f"};

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>