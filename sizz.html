<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Merry Christmas, Lil Sizzle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">

    <style>
        :root {
            --cream: #fbf3e6;
            --paper: #f7ecd8;
            --ink: #1f1b16;

            --evergreen: #123a2a;
            --evergreen-2: #0c2a1e;
            --cranberry: #8f1027;
            --gold: #c7a24b;

            --border: rgba(31, 27, 22, 0.18);
            --shadow: 0 28px 90px rgba(0, 0, 0, 0.25);
        }

        body {
            margin: 0;
            flex-direction: column;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;

            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            color: var(--ink);

            background:
                radial-gradient(1200px 900px at 18% 8%, rgba(199, 162, 75, 0.22), transparent 60%),
                radial-gradient(900px 700px at 88% 12%, rgba(143, 16, 39, 0.16), transparent 55%),
                radial-gradient(900px 700px at 50% 115%, rgba(18, 58, 42, 0.18), transparent 60%),
                linear-gradient(180deg, var(--evergreen-2), var(--evergreen));
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 900;
            letter-spacing: .02em;
            background: rgba(199, 162, 75, 0.18);
            border: 1px solid rgba(199, 162, 75, 0.35);
            color: rgba(31, 27, 22, 0.85);
        }

        h1 {
            margin: 12px 0 6px;
            letter-spacing: -0.02em;
            font-family: "Pacifico", cursive;
            font-weight: 400;
            font-style: normal;
        }

        p {
            margin: 0 0 14px;
            line-height: 1.5;
        }

        form.staticrypt-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        input.staticrypt-password {
            flex: 1;
            padding: 12px 12px;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.65);
            border: 1px solid rgba(31, 27, 22, 0.20);
            color: var(--ink);
            outline: none;
        }

        input.staticrypt-password:focus {
            border-color: rgba(143, 16, 39, 0.55);
            box-shadow: 0 0 0 2px rgba(143, 16, 39, 0.10);
        }

        button.staticrypt-decrypt-button {
            padding: 12px 14px;
            border-radius: 14px;
            border: 0;
            cursor: pointer;
            font-weight: 950;
            color: var(--cream);
            background: linear-gradient(90deg, var(--cranberry), #b01b34);
            box-shadow: 0 16px 34px rgba(143, 16, 39, 0.20);
        }

        button.staticrypt-decrypt-button:hover {
            filter: brightness(1.04);
        }

        button.staticrypt-decrypt-button:active {
            filter: brightness(0.98);
        }

        .staticrypt-error {
            margin-top: 10px;
            font-size: 13px;
            color: rgba(143, 16, 39, 0.95);
            min-height: 1em;
        }

        /* Layout fix: your #staticrypt-form currently needs vertical layout */
        #staticrypt-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Keep password row looking like it used to */
        #staticrypt-form .staticrypt-password-row {
            display: flex;
            gap: 10px;
        }

        #staticrypt-password {
            flex: 1;
        }

        /* If you don't want to wrap the password/button, you can ignore the row helpers above.
   But this wrapper makes the checkbox not cram into the same row as the button. */

        /* Remember Me styling */
        .remember-wrap {
            display: none;
        }
    </style>
</head>

<body class="staticrypt-body">

    <h1 class="greeting text-amber-100 text-4xl sm:text-5xl mt-2 text-center">Merry Christmas, Lil Sizzle</h1>
    <p class="text-amber-100/90 text-sm sm:text-base mb-6 max-w-[42ch]">
        
    </p>

    <div class="card shadow-[inset_0_1px_0_rgba(255,255,255,0.35)]">
        <div tabindex="0" class="relative bg-black w-[300px] sm:w-[350px] group aspect-video
           flex items-center justify-center cursor-pointer select-none
           transition-all duration-700
           focus:outline-none focus-visible:ring-4 focus-visible:ring-amber-300/30">

            <!-- White inner panel -->
            <div class="absolute inset-0 bg-white flex flex-col items-center py-5 justify-start
             transition-all duration-300
             group-hover:duration-1000 group-active:duration-1000 group-focus-within:duration-1000
             group-hover:-translate-y-16 group-active:-translate-y-16 group-focus-within:-translate-y-16">

                <form id="staticrypt-form" action="#" method="post" class="w-full px-4 space-y-3 shadow-[inset_0_1px_0_rgba(255,255,255,0.35)]">
                    <div class="flex gap-2">
                        <input class="staticrypt-password flex-1 rounded-xl border border-neutral-300 px-3 py-2
                   focus:outline-none focus:ring-2 focus:ring-rose-300" id="staticrypt-password" type="password"
                            placeholder="Password" />

                        <button class="staticrypt-decrypt-button rounded-xl bg-rose-600 px-4 py-2
                   font-semibold text-white hover:bg-rose-700 active:bg-rose-800">
                            Open
                        </button>
                    </div>

                    <label id="staticrypt-remember-label" for="staticrypt-remember" class="staticrypt-remember hidden flex items-center gap-3
                 rounded-xl border border-neutral-200 bg-neutral-50/80 px-3 py-2
                 cursor-pointer select-none">

                        <span class="relative w-5 h-5">
                            <input id="staticrypt-remember" type="checkbox" name="remember"
                                class="peer absolute inset-0 opacity-0 cursor-pointer" />
                            <span class="absolute inset-0 rounded-md border border-neutral-400 bg-white
                     peer-checked:bg-rose-600 peer-checked:border-rose-700
                     transition-all"></span>
                            <span class="absolute inset-0 flex items-center justify-center
                     text-white text-sm opacity-0 peer-checked:opacity-100">
                                âœ“
                            </span>
                        </span>

                        <span class="text-sm font-medium text-neutral-700">
                            Remember me
                        </span>
                    </label>
                </form>
            </div>

            <!-- Wax seal -->
            <div aria-hidden="true"
                class="seal absolute z-40 w-10 aspect-square rounded-full bg-rose-600
            border-4 border-rose-900 text-[10px] font-semibold text-red-100
            flex items-center justify-center text-center pointer-events-none
            transition-all duration-1000
            group-hover:opacity-0 group-active:opacity-0 group-focus-within:opacity-0
            group-hover:scale-0 group-active:scale-0 group-focus-within:scale-0
            group-hover:rotate-180 group-active:rotate-180 group-focus-within:rotate-180
            [clip-path:polygon(50%_0%,_80%_10%,_100%_35%,_100%_70%,_80%_90%,_50%_100%,_20%_90%,_0%_70%,_0%_35%,_20%_10%)]">
                Merry<br />Christmas
            </div>

            <!-- Envelope flaps -->
            <div class="absolute inset-0 bg-amber-100 transition-all duration-1000
             [clip-path:polygon(50%_50%,_100%_0,_0_0)]
             group-hover:[clip-path:polygon(50%_0%,_100%_0,_0_0)]
             group-active:[clip-path:polygon(50%_0%,_100%_0,_0_0)]
             group-focus-within:[clip-path:polygon(50%_0%,_100%_0,_0_0)]">
            </div>

            <div class="absolute inset-0 bg-amber-200
                [clip-path:polygon(50%_50%,_0_0,_0_100%)]"></div>
            <div class="absolute inset-0 bg-amber-100
                [clip-path:polygon(50%_50%,_100%_0,_100%_100%)]"></div>
            <div class="absolute inset-0 bg-amber-200
                [clip-path:polygon(50%_50%,_100%_100%,_0_100%)]"></div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "Bad password!",
            templateToggleAltShow = "Show password",
            templateToggleAltHide = "Hide password",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd391cdb7c2d968997486fc38c4b7ef9cde91fc7fc90368a6f1d496e1628bd77fe774eceeefdd826889b0f5926d51eef81d89ef512da980baa1101d076f643f09f341d00c1793c60c892c9ad546da063b46674fbae4eb8d84b11bc97268a253603988df376b42ef9991d96e15bc728cf8753880975e22a5798873899504f72f396bfeaab90217e8ececaf2871ed6546681d226354679da969e5351a581972389ef5f429b98861d216adfd38170493e0e0768a415cb1b588083a0f1a94b26cf1ce367d40606c9b8b1aba45a2f6e2d110fb6df2a6c197b78d4f259cfe4fdd676c90accd45acd0021d1630e8ec878498882e349245e8dcf8dd4f4de65fac6e6e3a601e819fbfdd2e7cfc9dbca301a6191939dd1ba25d227153a14423c0a1da887fbde0654c2751ba02b336ae2775fb78700f7bbe7d338b46452a2dafbafc502505a79f8a58ac4aba640387591090980dcffe1b9a27b74c1b4868a83b535226226615f5862e4d81ab903e8dd6ecbfb78064d49590a9965f062f43eb6abca8c6fabeed36e8ba5b1ba43111ba082c2bd7a586ab69152fe6588f38dfabd1a6f10e5850e84c316a4931b246e171b82041563bfad9fdfb1727eccab891c6feda68d250e2eeae8b5e69555d3f73ccc42dc4938f2e466b48751f993965a0a947dbb0fe878e4cc3b082bb301065e80b328cbd503bc7339e592e0ae6a32759b6044c7e004613809e31c9f574017e9cafc784568929a63773b969084385af3d02f920ace2e21393018be63c6b956b694801a55d973535e72437b91a8959b3efdf8853f72e1187ba5b9e5e97fe601df6447b276421c654d77aabcfc636fdb591701ee40e0246092eec1bd4f385d8a640ae70c62970a19a4de8894a4158f35e9b53b1800c3889eeb7001ea903ad815bef0299332867b527b14212ed226187e61a615613592d2e483a327f4e4ef760d90f48d92db31686f97b6a4d79659af319750bd7b016f7e73e00a07db6d1f423269821d540e1c232d4fbf6cf49b0d652fba32af10da626ee265803e2c4ff0aa6d8895342dfd84e66be3e8b0e98b9bd160dfae3a56eea4fdc4f85a61ea301442191d52eb708bdc328ab5d60f52d0d70dfcf551e3fd5682a1b552f3d6db409a9a10b33bdc9d35a80d522198647415164f9f2c6d284c7d11de756d0d3e808b71efc24d8c91c073ab790d7c0a2f8643e97e82c2310ec8c127528b9edec88881a65582bb6a4e33472b627ec49940050902f0a42280e65a2ed1102222f999baeae390e3659f19eeac20b3e299ad18040669bd5274143874ec7cf5b233d3ab9bec73e63ec1c577f8025b60973945c6775b12f24be7b44137cecd9b907ef5681a817113973a575a3087985a0af44ee626ba2602e9843de0edfae4361d8adc95faed906356979f8dd172ab108fc2711ded7a26c2be1cbb4657de216aae076e288592631fc318878e4cd7f5bcd90aef6182ddda3e2fc71eb3e3facb962396e3595dc7bb5b837d4e34762a86074ed0976c329951c2aca85dc6c2e093250b459c19d34f5aa5c11cdfef8434a59c3751a5f7e678ead9cc567bfb5731ef5b6cd61518f493fc08789af7d7cceb966170de24fc55d48e6b4100429e71066a956cc3365f2646166c37f4c555eae5564476e473ff34a9fb6ef109d0ba7318384b147cb1b290b4976da9ce4c72b343e916d5bafd171aaf30df8baae5e4a4be7845216d874e3e97ff39a2ff3ad7feee3bd4467899eec3af06f1d10de0ba47652df7b2abaf143aabd9bd45d0e77769f71601c083157955f715aa42a5b110f559b1b28875988bc072a6a1614f8e40c5dc4394032c6981f0ea1bb229893f216e8bb64f49c11a54b0ff7b0f7e9147c0394fd6fef1661a2188849392b90f77a392a9d243751202662714e8af5aa6a15ed5faff31f84bf71f8f8a685c2f0bfa1d0eae7cfbfcd9db1664b860f5c4451c6afb440ebbe1570641b2d08b37a23feac85ccbbdc580270ca6d891475c3e21063d8a0d8e46b3249a95ea930904f84de8e8f28485b02021b0f80437d1d6625876f4db7bca45e2f5c93d855747544d86f1f49d46b0e46ea591230c55b148135a90066484ece33c11900e032bbd67e1dcc2ccc5724ca7d03bf80ca8e2c6cbea5d09e5175af6369c2f968f195884a7e648788e12947a53c1750c5a5558a1f44da95244ae9563b17ec62fd0c4ee22f9173eb3a308049dcd49e1da1d3c04bdd660d6271047d4557e84f71bccc25f1ad40effac7887587c02b7098ba0481b168215bdd81c90e7093cf97da639a3e6a35f94946fd68f91704e1ea76366b1819f7173063896a4684b1a2280a83a4e60d3f3b21b139da6eafaa13458eb51483bcbc556c3d9de01878785fa13ca45ec589ea47153263c81b1a7333cf7114255638bf822ef5d4b049411775e0007042412ec7dff248d3f332d31edcb034721138221ff2226fe4d49fe412ee3a3ced63d346a73e4ede675d830b5755c97960edb1c283a74418f8bccb540ad8f7ed019cfc8c0fc8e183886828a79c476e731074f62bcfffecb5c1fe099f947f2e365dd89dfc5d23d7d0b0a5cd5b35346b293a98cb862970c59e49ada40b33d06378ba8b37b9ec24f24b775e58e349011975cc4b2196e41883ac168c052d97e4c7d2d46dc6c023eea1c3253d7192ac028707d3c315d70677f5d98738b16de4d1e62673a3d971eb54453f89baa2eb667f948c134fcdef1ca49f4d1c11468dc15ad7b0fc2b93cec7461cd8dbccdb7680c534d76764a70e9ab6421f4394b114bc9ead6393519de68043bd2e16cd14d3c787b4e705f7f345616758ac7c0e6caa3192cc3b653ab3721f697e9a32e6820b6d65d77629bcd97ef67d5234bc9927b455d2969311fce2f921ad24570062be2d8ec87cc87fbced645605f508af3a0d826c1ee536bd653a3a4b879cb80523f49b45c3ade459562a868e20aa698ff3074acd396a842785603166d474be9bab290374aabffdca2adeffda18b49d19b8d12aaa528635e95cccf5c58ec4c548fea134ff14e8da8ad3d085fe4096631889b8c00afb40d58dc9c8520f05f7a55411c83cacb539894232d39051b02bdf03328d8c0b8c9bf31eb2b445de5d76493ca9c337841c30161c0fb222a0c738adf27ec50be165ccc2a7199e94a65614e2d577aa27971cea4ad5a69a4f68c292917740cde83b355c12bb686604eee7965a93e4e5213c75d68289c52bdcb3043e7abaea6a75b6f1c65f22ce6eac708893afbcd8728197412b25a7e9f99041cf12b8db5ab65acb60ae4aea41e9c361ec4f1b765a9ca9c3c76311e46d9dab5842673984ebaeaf4b61bb185da3c034e0612081036ab225862f84e2f7a5370a03acf3f08b2594f487d8fe5826ef799fcd1da99470b285d598d2693fda29e672b8fb4452ed37344adbf8d27a805a5ef7de1bf6afaa975584b8646dfdfe70d704af06e4da104dff87fa5d1d3e2a02913b2eae2919664b99b2cb2a85170fa752b26006e12dcd4be7d7574f7878bf9758a1b34ad1fc38e8caafc34d5048a6c612d22570f48cc849be9dc14d715932eb405d8bfadb8ce0bef0908eecb46163498e959a4018aa040d53cca5cac845d5f4776be5e26444d2ff7a2d68f50ce83006fa9f42f5e7b11789ca70b06b2e6975b5228538739f3c83111777c65f4ed4ec1f1ae09136bcb7344396c77c62e2e0b4242d21f5e06198ca791f9ad8564e9789d071b0ddc69bda2f8c74acdf54c1f903509046d08759950ff47271fcb68679a442fd7d8b81029bbede9f2bd1319b2668cacb1eb278b25cec6774caaf0674b8959ef84654aa8a9eb70d19bc3ce3ba7e4fdb427930fb9b1350f9277dba0872cb721106067ccd51e1c4bc917c2532d14a8e161144a622e444ff522d07f2afb2a7dd1ca1b9d3b4ee597cef62d5027519da369f733491a4c991283f9ff98ab46110a0212bb0025261f4ebdbc1e4c5534550670d807ee1d20d04b3b42d679deb58e1efa244a28381544b201901f774f2dbc7a5a7f7d169a9ff6737ed9b4cea37fde41a3c4f593b8fc306b3e80c77d684e533529a062431dc0133568307f3718792292b7bf8d1ba0809a5c5a714f1c015ee5fe09228e1df9c030c778d779575860d4d3341e22ac15cd99c15b205ca4ba519b386a190e962f583c5668799153e7daf2dde398d2c0961a1b027eaeb1c5cc360300475a3265986e7ff79b5dbe83291bd5112251d1c8a5d1890d3aff2b1986167bf7d4e1f1a097b4a4c14d57a62a2bd6041d2d478a84efc879d707f458302894bff974a854b9724729206a333b156e0e19be3fa06e82bffa339267272a887e6aeb8f0fd60a70ba1dd7b0bdf13789662adb46dd784045544decfa2311d2f425da7fbfef8bc8ddbfec06534772915ecca7d9dc9d74da98ee02d598e75378be1d181e2a49396b2e0bd845bc8df02a77b74879413260b9e7c07d157bbee8d0fa9840316a527173d282a1511cef7eb45e6ac94960eb40d2d95ff9bdb8a229712504f396c4f3de002b1069e9c51e408b1ae968e4672285767390af8c6e3af7486d82b4b70fdabfaf89c86395b4e7702ef185d1441cff18cd972d923b96994dda55fff02fe6d4e05d6904569f3ee97e26857063e9aecbed39cbe7e9593125d25b0afc5ae24982d98fe64897de89f8645b27e7479b66998ab8259728f1daee4a3761d517808b82aa5663e8878e78253a4149c99ce2b5caad6b45d6a873143a9a8ad7b40cfcdd450750dfc44349d69dd6d1fd8ca214a2a78e0e374582a0d4415d75d189bf696bbf281046185bef0b181add9e898e0c3cbe5ae51731932fa79b092bd3783c1285a67c45013b9640a43418e0575885410bfda104b725b4f98a7cde007b2cc8c244438197bcae5f3205becd589d65691ad7d36768705ab23357b37d8b0ca377581fa8dcad3c9195ed82a109dc7e0299eb0463850f86e69799bfcf01fd91a92a8ea4bedeca24bce361e34a2c294058f1f9c1c5c4c0508c679f82325dde05a3e03643f23ce9163f2cdbc8fe08afdccf8eb2bb2a7a55366f6d472ceb79b12d72cf0d6353f9828e5b1b3f7b28f5e00041c5d837a91be2732fabcbcfcd6e93b7ca55d0198ef80e5cd8bb140d65bdbc93d0d348118e7675123a58d28ae5e913b4d4f2635b87c12201770079ddc3d88986e7d40dafb69f43bc9dad5cc1806b3ebf9264c1d38fb9d578e7dad9a462ca57cc11bc6748d8fd1eae5d07d3ced8376cd63bab7db82f80dd74950b6b2c915009364509bfeb7c26e9743f0d73c5f29bfac983cd9058521d18cff684daad16516cbf441880e9da43326eb2916589981022f5c442bf852cd74fcf6e13c59dd81bc2505b24028f3c02c17b65d0917ca0a46660722727e115500aabd56aae20861569d501e973aa669b0c45895c4a5c0a09eb649626682a0cf802618e93fa2ec2cb80708e8f71c3f248336c05bbe5f8e13633ed50bba905eb1b27482f04e81f31a31568dd4b09b0b39290c559bd2066ebb618310395cc9897a8cc34bb48329153b81af18975ea50dcbf76a8f1a48441568f5e087ae03ba253eaecd2a8f48e46190af5dce93fc724733aa43348625d77ad0e090518bdb757ec7b231b8aa7fd0cfcf55c0b64fbd052b0d8f313caba67e454f344484d5451f421fbab0076861d596246a6bd4cee2eff03d75ce3bafc9bf551d7d1080aab6d019ccd623a3b1d4c8b248952c423ca76e9a9d38b9aa9f48fc5a14d6903d18c622001189ef5064bab8bf244a33f9a2e30362bb0aa1c83b94ad429d53329de033abe3cb3c729e48813811b7f8823caccedbfc9a4beb52dc5944498de596e8203f2499378047496266de724e25e3548849d1dfdb1fb866df0a7b987d18a42b45ab0d206582f7bec46353022fa45ddd5056780483d06408befbd7b9e80a7690b4aa35bb94f346224f8bbecb756583e5d14741f147eb35ab6852c3a48ed5ba3f74f90fda8df697b72cff663413ba63d38dcc8d9a09374cde6a9691634cad67bceda3da9041e1fc708e624019e5011105562810fa1638a4bf11892cf99470671a2233b0ad08d29e42f177b98ee04006e411d285f96bef7770df5072137c8929adae2e7531f59fa182f9e96959bc58e90544cbf38a6b21bdf33e657c89eeb2a6c6db4e5bc41f31759c8d090a819da82a94a0e2fbf974bc3c5c9086dd237bc5611ed941c4ca1507050d31889a54dd3204069340ddd3b675b1e8255c016816fdb28430e895efa55eeda468e12c450e85946059d0b7106d2e15347feb05206d0fad2c1068a4c8b292f55841bcb2adb5f66764e6dde0643538245b25419d72c2c2d28995e099e1014d384cf5f78ea622638b667800df95ad15c465e331aca96a8b644bcde86e65108b59abbc08f126e643d6709c61b7a47514e2c237f381e316c0f0176578506c9ee11462ed6df1d21466d9fd5eced779b8727e49666bf1384861583273630905d19f37fae52e074205a445eb6b4421ca5bbf891a62060dd695eea1404282716239c08886fe35efe8493e97763bc95b1f72c76c18360fbfac2340825a11bbb07c1127c6994b87f90029d352f8737a0bd031cb31d53f7e946c822ac4e9be4fa22e361fe7710b8384315a48eae5110542520edf17d0baaef473a86c7a1486d01d70b3ba3f1b953cf3cc04d68dc18adb060ba2baf8daf61682b01964487651247a2e2b665fe07ca2f775c2d3d37d5ecf244b51c077174bec829e152631f49071ad54fab00f2827e654b670e15673cc7b8292ea15377a4951337c7d647d48e7bd776852f5be71e79a9acaadb33e1da9be7a660993f0c506b4086c1a3304c75184394305aae8ea4208320a25a115fb15d1313829ecb4b1e59c34c169fcdb31369a4db7642b864ffacdbb16148230c31df90d59aad3d880c61af932f815ad15e54e691dfb7ad3917c1557d5fa76e39ade343546ca37b3af107f553a84ce0f0502aacca5f2e58649820af8b181191444756ff59493ce9ed5d8ffe119ac5752c59b8a85964534497c0f2e0f2d1a202f2e256e67f33ed2fbf16cd119e3374c2d626b4f12ead9c1d2b120c4f9cd00485a5377ee16820faa90874ec40552ef36df8e1b6264e7263fb45846fd44afceb9fad05b7b2d8af8f6acf260a2121b023475f059b5098e550d857bef7cfa56ac3b774e807b89ff6e0fbf8ed2882e642735cd70adc129ad305a85272474237f0611df5a0f010d7676fe45c787443c7d551d368f8d2973dabb71f8893b32145bf5780717118f39c8a4c2fa15262b79cfdbe678dff25d51c280d81e063e0393e67bc8e200efdcaf1223c1c022c354c289d0971b678a018bcde2be1031816f620df8851722db16db50c6792e54a5c3e2cf69ad304f37cb2465737a3453407fd31402b48439bc8c04d35a45b79ba9e732a003936f68b21c700ab99eeac0f4ff3b1963f08eeb8492b3e7c9d2e86172cd5262bc0f6ec5e16cd5c36824ebcc32117556f472abd0a63068041c2d19ade0a54a1159965b974adc3a5bdccf1768fbfb776d6aa8d07d48735a668cd9e84a1bd0c2f9413d5ff43efc9736da7303703e531e560703647f543497afeb3b57508773bad85ef77c4410bf39cf92a5a9c7179eecd63be41154806730ee0508ffd709140fea00ce387fb66e4bc3e0a082c280633e19945ce881704124bd007fa905d2a32a27afb5ccb8ebf62bb5d4d7c26a12cbc5c894d9bbbf9995c3f356c43ccc6962ff24017dc34c64f5a0a1410671680599a62ef876b1830e648c1a80b54c1ba93d7573a168f1962b5eeea214aadd99cfbb986552630e4f808392aef08730d3ef647c6279fdc85ce12daeb53ea516531009af2fb8fd88fab91d69b6ce85ac6a3a24d078b1e61c2d5e20644cff3441132989aa3989de5753feb69bc83b50b8fddcbc3a177aa86715d5b0c98a1f9ab789a339315de3cace6dbd332dccc614570d66259db12d0021a95827adbd4710aadb5ab3d9f1e68c4bf0777db7468c63ca9c0040f2f37dc1a8d1fbcf0dc00926f97a72fa82fa07589801b0105072221a4c8b52541ac9d06baf19dd175cbb4f3ce8343ad26a3b08ff7a63e458512eac32b8fe9a120820d26fbef469f401b8dc5b53a11937ed8f79fa931d584199a51da6fde30d3e16b89977074eb4958f24b2bd6fcb24cefce31ff8e69bc00510775ed442d11ddecc620ef82145702b65212514995d3bfafd0e8611eca28c69e728bdb9aaf2e27eb0228070fdc0b5a613a7b4e55eeff428e2adea170b2bb914a48fbf07c5d39f7c05eb8d6e22170e4ab355a8394c3eb65d3cd2cd356b54d782c20ed2da5efb24e590bf532130ddcb8e3f810f02849b248f9abf168ca81baf333703df7d8fa63af8c1db9a9c868cc2a62148f008d45703a5c850ec899321c98f4eb10f23aca9ac535bf78cc148e482ad47cfe8e127eb076886386347e0fef03d8a5cd06b05470dda694b41b37ab7ffd70082506bd277ca5b4510cc8cce9226ac4e699b8781fce17091cd623fec9c4763856ce7ae37d949bd36182ee975a28efc9a4cd075e53454bfb22f28cda093614222c617e249bda12d19bdbdc333f79d335ad9f93545da4b33ddd32c9a401b8bee21c9464fafa191088fb1446afa3561e9fd58c7a96ede75c446b6de9fb76885853b26d798a9053c1e31c090070c5e3f872c84c28fed0deb6965b9fa0d24ae47c650aa228b40d7193b46609992bbdd4746c865efd8b047c3cd507b3efd6e2f540447de6d964b62b3e3a06d7e8bb5939bed7ee519c4e8c707d2e9dc5bad269fdd7e8452a719337567440f7e5c7731656d42b389e8561b05e38863ad18278c1141d319bf1681e7a0e1dedcab893d2df30e16e03095c6556219a36553aaa66e6456c61ca706d8613760a543f2d46686410343da3f67c69555fa38a633297930a6bba011397e0bbae3ade30e91e80fab04886d009c9d5693fbe490ec2031f05827c2e14456aff22e589bf3632bee26ba754534636eaa18216d354fabcfb122fd890f28f7c1fe8efe474e739f9af3f566eecd67182d69ca413a3d72df91df24a23989c476958bba7efe7cdcc97e242be64f86e705f40508b6d565bf30c5a151c97dfd055380e714aad2bfeff24dc55408a24cf8830cb5a5a5068a1124ff3c37c3e6246b7c370addb92f815ee48fb75cd310008b0c41314e024c7b5cd0e34d2c0ff33973869829efafb046ed76cfe27e3210dcca29ba649f37bd04c7c9aaa5a6afbc60e57517f1ad61ac03e3633f5b4e2d35f3b3212ec5f9b350bb12f7108e3be7aba2e9b2a23a19acdec6b99f23a88c1505f5746a95733b9fbaf11159c8105011fe7f2e8f8527c2db8f1767ef55d465936f6a48602e737d44b1cc6511faadb8cf205b63b24a670b7c92868362d4371ec59973e004ad286261c1043911e3b4dc9c926e890eab8c496eb0b9a489dc50bdf28ede9902f7c6ea962f229ce6de40ac93ad2e01f5bfa9241f9d48c96861ade740d58e15dc78e77a022116fb0ab86cbbe3630405060b68448d0bb04da70e2a0a65b067e678ea77dbc662e6a0112004f30bac296fd79b76ff11aec2e49be75eadb62deaf6ef467be9301aad4e3feb3810d4b76c2e6833f9e03edcbd30537799f45c6d3ff3fcb9dc4a30d66e32d27f58468d487a470a4a7d3b7613ae8ba6ce58aeb6f92e35ecb1ba68b50e90266030f3c18e0f9eddda4fcc77a41f98e08908103e6c98ff06555e42d4f7ce5c9f144e77c6754e985fd9af9d3b43ae20df6c1cc66cc05ce23485a6ed03aa156f6b892a31b252ebe75ca89e6d0e07b1a5c2884edccb90ae9c02d3322703b8ab9f4b55967f3a0ae197de6c806bfe167dc76c0b2954e94ba9c3a00471b386b754d16d5d9352e0dfb89ece37b076ffdea1dae7c9e2dc41d3a39299868e94891ec8e5b4decf8a67d346114e44c553beaa47bc3543b64ce6e1bee29effabe07d40859b274e0a4b94012efbe735e79595cb8abac8b7edfc5b782fe8f60abb55b9ac8616491c0688b156d98c4fcaa5700e11620fda2ce0156afa13c20f7310c5f118351299c39dd72712e98c5c1a9add739ec5f553331e9e69a0fcb906d1fbd9001f4aad9a2a401322de1c77b1967854a82d653e151ba7cb78266b419ff522285d65072d32ea53e44da4ad155a67090ff7a08fdb31b4c61c302d35c77e624bec264889ba1635ac8774cac569d554df93d946ef4a91c92f9b64d12f1c5e45eb03110e49bc12c86b29afb5b74812521b7cabb4b1bddaca9dcb84453d865ffb004d07b7e22975496569269639df39210106859980de95011975ef3c7e305712dcc6ec5bf5dc57947c7981e3dd0561f820ef470f354859144853f00fc86dcd32c3e417f884773bb59de96c58e5f4ce4e129fdd6c94a5fcfde07439ff54225c2b8682edfc147cbb74118d9288a04b04afe72a19dcbbb2e794b7a076e8deb90f32f7206fc2b146f25a25248876e67463b2106a2ace6f18017714193c51c955289392b259651e77185ffb17ccc01b5fceb65bed2d54799dc088b86b398ac2859bc64701090d6a37f62c9a4a3c6222a7f6bd0d3a14d44829980e4d9d5c016e1c13f796678627ce10328fdfd048c5ca9203dc721227ae89e8293aef6628415fe429ad35fab009f4d918a14982beee7e8209ceefdb76873b8e213828b662ac14317cb3f416b37765ff6c5ec363bfb4b12f1d0dfd4d7b2c092a9b8ee5e1178efede4553b7ea105c18886b1eb1163102acfbfc4b0803f63c3238228076d01ebf5aaa3931904596b7327fa6eab8cbfd79b30998775929bdc3e127e93bea23dbd380cc7113a3e42506d779627e22427aba3c56b9839b78e130662c48ce4c86c231b04a95d454518929b34c2cd7aedbf1d36466b7dcbd808ef70d1e422cd1cf2b8304ea439b8616ac0cdf30e5d3b9fd358a5b0f251f522b7c0fb3ad257ffd6f558426fd1cd744cfde037e8d2470839018070dfd99b4d03384a5777675e1d088e47657f61c71d23091b38f8d361006f836d1991eb24d9271b4a60a981fd76fde401903df58d929d917aee087e9ad67f4b97b3aafb4d354d7f611f32925d747e9fe186618152622784ee2988a20d01726cfe89c89dc5d1dfbabf36f0e89453b8f2bdf505b1df9994c3ffa94d94877529ab79970322da51a07e478e5e9b98adcc046db11f9d0e7b97e55a378d62c63d6f812fae84165a595e869ed676a3a36a8e3ae34a080bf3b5d152079cc4541ae2e96ba74a27715210fc24d47a1531b800cbe27a272acca726d02cb1a26d6f5fd569b60e2d52c884a52d2ac3b95863dbbdecd099feefb171c7123c1acec30ecabf6f00f98b8ba9d659b15c2e1f6ea25930a12422fd1ea1b323bc6bad52faa7fff2ccd6a49ee8fdf58f698c105a267541a3450ba1c260f18ea3f1b10c22d815d34d642913c789288befd078a568e07771bb8b4d6280f48f17d098251200eb002cdbfd32b2d9896fc948bbdcbc7782cdd523c74aaf19895d9aa5293cb87fef0d744aee59c4733a815d37bafa54872f40846bd3373bd05cd690ea7bd5ced88dcbf6cb8ba3c3ff5b4853f254d7373b04821c6e1bac02fe19fe995e342249bae1e592b03e6177b640a9861c748e577820a9e9c8232b72feb3dad196d20dd2a7ac342083fce0eca1136caeaa0b7b81daf8df14b5ec657fc76f926f2ea924c41f37bb5fbc57932e94ddcec1db9d01b17fcd1a6e7f3dcdfd5fc94dfe9ac645390df31fb51db6c2d7252db0296681b61b6e699d777955332436088a774f73c297c2d62cd7ddc6f3df042c01296d62e7b27c1dbb7ab33b77e537b061666a24148d446f2c2a4afd1873be2c7999148dfdd5dbc5a85fc5311ae87ddc2734fad64f8aedc4e657cacf85323f453dbf2f19b242779b0d48635705e2564d673be017bb77b172f1a52a9b4086be11418618715b0d2fa6b0e6162fcad3f998f8c8b773d99f06f1a5de451348b11111fa7c5de79b486a861465ca74af18644dd327ec90ac89a53abd71b31fd4de86e13a7dd549a57d214af14598658f6786a9dff77f6027f20f81f6a5d00e116fd8233900d00892ac88621712e4ec13a1cf4b00ecdb2114eb4418f75f251bcdf768f502da3c5eb62308d0d66005c1b5fa76e8744a2e7cbd916c965499eb57e9614d2ca8ee5d40c1719ce554e74900b94a54b0fa823fd3acf6c47dc060d21aad25a31367f33c98451065e12b0ee2e2e00ca1ef702aaca9556039cd1b907fb7efe438132bbacb8298372adae02a5e32f874744f4e04bec8659bd2a9f3ebfb39f6302ef9d29dde057c80dbee8a3575ea4e41f4e4af99e5afced4393f7ae6a017af90fd333509eaa3f9d76720a2d9b7081b173543e28e1c58400f63158facc64c6ab9d1cbf7f63a96fbb5c2e7fd98e4b5ccd9491decd8f92fd22832fc4a7351dde038a03f893dc27ced917f5350568ce2512daa283120fb2cd58bfeee3f309238d57c359aeccf793e074460182324e33275fdde207920907edc1503ac06a2a57e66dc1a4fdcba53cb76fd7cff2e6ba060f25b2a68d66850ef8206ea9c2748461e8422394490c27e3ff21ecd8c4a3a8bb9f1f20d7d7ddc744ebdda93c67589b605774348fadf53c77820f358520184cb5a4507c8cae10390ad8d2aceae47e63f22ef7e197bb4495a9c2fd0dc38e1f3af4c1bc76d888fb0460cf28668f09daf621eeda175bbbed1a451f6365b214c416cda357024d2de0af508f13dfc3a1a3e5f5437ff7fac1b861ca3a4d20b65323061bc05990da9602639accdd92fabdfe182fd274509ec84451a07e19a5c0d30239c80929ee73744afceb33b0631bd509a1e55df917b3f7ea3b3bcff46b146abb654607617f4d7892f84ff03ad46bdaec24f7c09dd61c8ab5b938332cd3f5a111952b6c54eb7d5f51f11b38def252194191b835f61dc5ed46c3de7f9c7a279e69fd4930241a1f3959189ce4a274106231a2b981b6d68ba87c41beb80df4216655429ac0721aaa1822a637ed515219660271504075b7720f9ccbd8cb1b06a5c485c18c4b43e1e1ea1afbafeb0233870f9e34320571f95f2749dec3dd2f7556fee94198141be97ada6388101cdf9891a7a5b881f42d444513fe48c331e0b3c7096874f01352ff1669a86762a57f090b38fe9bbc027d4d6c2aa3dc64cfebf1df596abea3d62a861ce3b67f4a2b6b06a0c60931571363c08db475a847ac5d0eacf8087f83190de1504aec97d7b1da34c75037c0bd074a2b4dc10ace115f1d4287a82ecb9a571fd2a68f364232b12468790b19093087e7851139b0020b1eb981afcbdfff0065e13d24f5c7496fb83f12217a5a2690c3b58f4e7da1fe89f8db6d08c8208b7df3740ccf46b64ab85901aa677b10a7680807ec582b95538d13e09f633da44f1d4f581798aba4c66711b9c58e456d78bdeb275d279c129a52a43491be904e051afc80b5784b02bd239cc2304a19637007f2f411a945fdc528abae7f80822e514295990e68088eb1a944c875aa6ab4a0b5801d5fe03c88178796d7fc92f5af48acfb01eb98a1a3e372b16268519d3bcf118c546fb42d6acf1638f87b4307b0abbb0943c6a3ed6284fa2c6bc64d61f3f2a19a26fd442b76954b941c12fa666d99470d618d1ccb7c5a922eee3d9d17dad6e5378fbb01a39d4aad1cfc913a451f48eecf24a54cc4b7f92f4e9ea5e2d4c4fd1f99dc6343a28e09c79fb3d2ed79bf07177185530dfef3f267a7d1f43ddad542500f0d2dfd9631709a65ef96ef4ae8c1fe36689f2b378fb0f1030697e86aca3e3f720544d4e1475eeb7c32707131133de2fd4d3f813665a02238025e73b73e8d09992bf05590ac628d4917ebc3ce1830ccdb6f5f2fdf4f548760fa2a84a8a5ac82445b64d90eda78c2b12cd89f303ad6061a3a22aac77cd4d4065684b95759aa531cbd2aba76f379c24a548e3fec0826ca139903dad6910fda432ed0b591d20ec560ec40f84140181ca7a6d2560c917f27f0b29a7e0ca9a07b33a9e199307e718bbd812636c6c0fca30bed4475e6f678325ce4ccbb246ca82737ae6a51b7ab6f89c18e4e7e0e4b5ee3965f79103e1d43478cb2bdc4b9ff6f362d4fdd987979aa3c4402a643e2b4017e35fef9c99ece23c48e099d75ab1e73e0c39aa6791d13ff5e981b298c523949ecb681730ff6c09ea955414b008a6d913b73649e194f09a274c4acaf985632b5e8f02bc6342150076242eabd770c891316a49dd73f9453fb5a4c1debffb368bec818e3c05f5de4209648bbeb741a1ceef3e2a9c9bf6aa5254876c2818d9a95bb75f1f8c33c12e3c8d1aa3ca44713839f937bf251f4625abfcc10521cb56f5dd0ed66374addc4685571a307a30f1776310229992e7a21bbbcc554e1b84709931be79abf9ecd80e0470032665576b0d68c5bdcc643cde267a9b4b188cec86f71d51f9b54e1c6ea7230e8cbd33c6077e675297a4befeade8810a8f3afdd51b4660c63f98e96b4a96340e4796186f276b8daa55720ec1112e79655bff794e368dc7e7f4b6895ea86abc191430706106730bd93d73d016bd7c25f3b50002652573b9c1f5cdb8fe457f8e9750b0ec105554450d92582d4bd8cf0720784c3ce6a84ddeecc3e3c914c75dc128feb2e0039afda83358e124ad33ff7d13860a75f24b6d81856216bab9d3c6e59e4ee83515e8ea35adb11919298a5636d7c6fe073577b990c8972be808c7df4247bb4d1938b573da904a0984e888e9a05d54280b4cb3dda55e40416643a08b05d235a9bd67ffaf11566ba2e1400ed9a7e83b50e7bc3882c8a6a0f731ed1fc8e3b52b7d253c8a5be6a6a17d1b8cedeaa154727f742897cb5744eb0d927ca1b99ddb72f5330c5efe32ec97662185171504bcb3b37d6c7bb22c30935cc0bd769903b4a69d6a36e64f5c96446ad35cf3f57c0695588fc0a2ef20403a1c2cde9ab69ce31f4e733da2ff463f2be1d715d24c3d29f48c306460321307b80d75c3a3341c50bd595dccc7fd7dfceba946cbec6bd309c58a655bc1bf51f53654983085c7a41957a0f5944bb514782b805ee60c5cf4cb92d70a9943d1bf451ffb7530afc278d4e943a35abf246a50cd6fc0f07a8896cf71ad9ee81e25648e0921ffee72a2da4f3306caed3fea142662e7fa66a3aa68d0dd8a556d0ed9df27a60d694471ccd5f1330e4a90ad30e7616ee6b70aa07e2082881aea825b211ba336171c85a50afd5753a40da4a30668d97ad6fc2c6a2d8a7e0c52cf074b2b96789c12b0a4e85142ebdb251a22de02d2aca00c25a4dd3c3208209124f09c6591ae27d551662e91685219a1d11eeb8f342cc9818c722cd848a1f6213a0d266f9ec0738241d6504080e64ebcae3ad41f94734e3cbe5c39a89cb2e74843c494cb20532e83f9a22b0c7425223fe13a836639b3790da230650701aa9d9b43e213403e586ade862d1dda7295c72f5c3aa57742f21cd9a3deb47a4d6c0025683b789eb73001c081e339bd46cbeb0b8e0f6d57c1017b19b32be935b76b2ac2405e0e532bcb288ade685c450f4d2b40aaa5c180278c68ec6fe5ee73bc2228e50496f6001fdc04ba7e6590b6e18e179a73d8bdb7f3f5eb96867af6240ef74a81e0f8c1ce96cb315ab22cb29e909e55c57218d453bbb1d44edecf9c482f767576492c52909587135782f7ed7a60a9d746be47b6f4c851d8eda9cadb5b77b2fe07c5e9df98374c124970ea3544c1c4054ece24b4352b483e5706c67ddb582558f837b6c3f0eccb251d8ff26ed10e9752e32773f1c94a19ea9af1430901314c6bf8ca43bba0cb2814ae73f2b8b211c5dd3ed486cba772173c69f5e3672b97eece858bf43f62bf1ad9e2e0354a72483b80022155971cc7db2722df87ea9881f2b4642886cdedbe56ee9861e31252c12fabde571b84cebc291ca3522a6a293f5de1fb63f3a17ddfa941891e6bd1272210c6bd411cecf64b4591d70ba653ec07d4f4f55a7345e062d4c4b2c91d590a3f10f4fbf5ad6cbcb6976f6716346beb8136cdd2444a4d7e5eef9f80c5d0ae23d8e57ad8b381482d68302c5d684ce25bd1b547eaeb11ee5c3f8e58e037c9f8ff392ea73b9fa62d2412c281841a33efd1576db8f41abadaa8ef198f37dc4ea981c2af27f841ab66fcd96b6ee19ded8e1fa9ac4ee0f9d4f28577285bda3a98b1899d063971a8a8e3c55463f1cde826d1a9cb284819615b16e1831028ca2aeab111f3a0acbedda1fd02be04d536355802f5569ba62b6d8ea9a508150927f4f8f8d15d0f14092f3eadd36b41d1b0d9a89026e003aa3cc04adcdfd058abb28467f06e59ebd7e7498bc9f080234620bb191839446995d3b4b7b83479bf7fe691f78d43cdb8be5993bf7702fd628413342d6ec092464ef3fecb3703a8494d379eab3f614c268f01c55b7601714204ea1e069e3f9169f6526e0ef744737fae2bfd24e0296c832535fd1039e8593c0e7b5a5e3a6bf662c63a71ae687544cd3e96f635bc3837cbca2de07a86ed962e4fe3a0b779274f16819d22ceaf36c5a23e1271b869bd83cf7ad78332e1e376aadbad1d616097f3647f75497a2bd5e5b7a80dfee5609b9746556788a70be2fb1265b2545b826235e3d25514b50e995ed8bbd83b551bc88ead0bb41c0fd841e051cf6504fd42d9bd723b3a4b04111e03e48bd9356dd1a01119f934c30c23da82aba0faadf12e1a0591d2e610c73040f216d0fc033786e15d1188509bfafb69ae2ff2da53cd6a0b46af8c586b78206a15f6a145151b3b5f443e7236c3713ec15c8a6f821ed86711a888ce459d1516e96d1075479faafb5dd404e50e7a949d1fc2e8fc1ca0d84f6f809200879dd7dc3882763f37b8f851ffebc02d78a752817cc88d1ba4b572d18c63afcb2e7d79a4c129f8bc0cc90d36443a696100de13601fe9e060e29cbbd1ff018b5c12500dd227da9f265c273e83343b2852dbf1e108142c503b62dd9239ab1c6af8e7337fdcbd93b75219318d43ff4017f7802f8b52ea4da9144c8dee0a09f7f73a8f6341370bb336160dcb8a25eb6de20754ba4f3eca0465921878218e0e58ba1b1c9ddb07bfefd6c031232e9a7d1200b372f86c0e7fb2431bb39955b34144d478eb9414b8fba841576a70b3d88d3c63c21b9dc1b667879e92a2759c44cc6e4cbdee53f3e48ee1c69dc6b59464d95101ab4ad85efca7ae45eb21cea27967abd43bfe4e25f078cd676b32a13a9f88fc322042b61e56636afbf2bce8c6521a2ceea46d451a82fbc0584f07a7ca5cc0dbe04a5c8a026d69a8c0b27aedc0278c9857b0bf42b48c0e0fb3a75b62429033a494111cc897551a7899a9f7c189c48557ff532e24b597c901387722c754592a9e62e1bb7412ef525d310052380e20cdbdf52a3f5c1df1c0127c1bf237cc7ea75fc5e93dbd2abd194181d0901246c605cc73afe08131c27f6bc83f2c5943d0e8c491633ae36a0e90032efbe710d2065b575ba7e7bcc61f4b40956136de14bb7a07f8a61406d266b25fce5da6e0d903e9b364fcd3d6604709395b78f320cd6a3d3a01ad930da3f22a26ec46a219614fbe3e06e39ef213d2c7ba83385abc23bedbe4faddaa6ab2d3409d223fe4ff5fb634ca6909c98387d4c0eb1a13e86a8e55e3ad761e502aacb22909cab73482b6055dcd7d19c8852ee082f3235f65d82d08ff2ab1d187cc97d99f2ca995ae9500d9f93a3e627500bba718fc8f49fb1532cf2bfc903a6b585dc7ecaf96bd7aed347846f206c287c49f679941254f352def056414e16f6848de16e7b2e3310e67afca905825d691a6d246e4c51b1ea1012a854e3d7604651cdc40a09ec0036cbe80d84445dffa4c79ff74350c95debcb3e6f75ee2ecd89733ae2f818c7b51fc96bcffc30da1b896aaffec0cb99b3e48de3c57ab777e2702220bfbedfdbabbd231660bb6a77aad5be492c58dc058fafb8bbdd203126c46eee832791529f36f48234a7434547178b0d166655e958f928094feb214a279c394ac61b5eec8018e62f20167a85636610e8f7de91e105f54769de743e9916ecc2c0180cee9cd2f0986fe3f013af9d424eb4a75c79620f80916f65c539d89214f55667f268506ea857a60477c8b3cec160ad48ff6d105fe9768940e848c964601b69367c5237f247f5d3305ec8da703d2d6305050d10e8b06b19a601f50ebbc75f5a6199112250dea29a618372d9eb259a8a028c0af4370be5504236b11e8a581ba3ae098bb16428e0070369471914dc4fcecdf54ec20599d11efd3be06aa26869dc918e88d2739ddc4afcbebb81ac6cc1cd8876248a29fba74ce9bc654e3b578f1a177e561dd0443873d14e48f7fb7b83f8e961a30b328e497bededa52aa40538b406ce433c4903b4680944318898fe1e2ea2b2dd5e8d846611878af469454858ffa9944ca143e0353be0657af289acc143ede0ef34e93c7457813d34714f2215a4d31120a7bfdafeed29679184958785667881c06f595bb280ceb117055d778fa994953fd742b557c03f646052b18072643849945fe23b83063fde0d135b14b168617273bd9251824fe9e72d4aaec3272e259d61d799ef9e94461c4533cd47d0a4767c71d2c53c78dcd3496537bd9558810e29b900ac1ca2468b198576af2122e986c8ba1f14f23b2873865d42281fa411b37860d7dadf2deef2c02401f82fab8f02299bbe3346ee34e130720baecdb39e9546d2d00476f2cd744fd1a837d4387e57c081d11103cfcc61e15f6ecdff8309c333164187918babec3395e149e79f4c48faeb2f523bef497b91394f520df748e7602aa59cf46a719e1d367ee69846fa80a112ecade63ada3195f91685194812e7c397145a1ac2c1fa960a5af43137ce9192e8d858f7446ec734dadf1ad8f8737f97bb2c31914b4d208d8994d4b17d302cf8c5e98c479fb7e1909fa6b560827919f5145af5c46f846f806d03bfe56cb7c046e6d9f97fa7327f88d94662add5338242bc0b2c242e6579128a197fe748c11d038532b42ba7c91d132e5c0ed45608c5bc82e7124a0f6e41509f9b4dbd9163fd5cb13bb78f944ebca48ecb4a165b9120f61728558b750282f49fd2ae6390f99241a742d753d49dff8a45d71d34c1baf5d609c99d9eb3fc8809b49b26b6ef3ef4904acc5a4698ea7cd08f70e32fd12d28fd961dc7f65a593b6117d8a8b01d7ad66b69c51e95855711a964843554daa230747fcf6082a517f217cc59f87ae5deb8d1977a2e541dd1018763fc11cc0e232876f74b994bbddbcf16b2f2394cf214abde8725dcb07425f8f1bf79734b0a7bcdb70d5345efff370ba758b0abfdb0d59ba4c9c3fdae5e2d37c1680f55fdf44d7213f986fce80b787f93448ad36a7ec540bc19e4b8b83c3fba0cb3e49331990c93bf008a84e1e231cece70cd9d55d6d6a2db160b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"87c8a93c9e89efacbb43c81c7d6ccc4f"};

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>